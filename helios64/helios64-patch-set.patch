From b7893ac5616dc2030fd654cef05271f01e7335ad Mon Sep 17 00:00:00 2001
From: Aditya Prayoga <aditya@kobol.io>
Date: Tue, 15 Sep 2020 20:04:22 +0700
Subject: [PATCH 01/26] Add board Helios64

Signed-off-by: Aditya Prayoga <aditya@kobol.io>
---
 .../dts/rockchip/rk3399-kobol-helios64.dts    | 1154 +++++++++++++++++
 1 file changed, 1154 insertions(+)
 create mode 100644 arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts b/arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts
new file mode 100644
index 0000000000000..27e6bb476962b
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts
@@ -0,0 +1,1154 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2020 Aditya Prayoga (aditya@kobol.io)
+ */
+
+/dts-v1/;
+#include <dt-bindings/input/linux-event-codes.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/usb/pd.h>
+#include "rk3399.dtsi"
+#include "rk3399-opp.dtsi"
+
+/ {
+	model = "Helios64";
+	compatible = "kobol,helios64", "rockchip,rk3399";
+
+	adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 1>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <1800000>;
+		poll-interval = <100>;
+
+		user2-button {
+			label = "User Button 2";
+			linux,code = <BTN_1>;
+			press-threshold-microvolt = <100000>;
+		};
+	};
+
+	beeper: beeper {
+		compatible = "gpio-beeper";
+		gpios = <&gpio4 RK_PD3 GPIO_ACTIVE_HIGH>;
+	};
+
+	clkin_gmac: external-gmac-clock {
+		compatible = "fixed-clock";
+		clock-frequency = <125000000>;
+		clock-output-names = "clkin_gmac";
+		#clock-cells = <0>;
+	};
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc12v_dcin_bkup: vcc12v-dcin-bkup {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin_bkup";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc12v_hdd: vcc12v-hdd {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_hdd";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+		vin-supply = <&vcc12v_dcin_bkup>;
+	};
+
+	/* switched by pmic_sleep */
+	vcc1v8_sys_s0: vcc1v8-sys-s0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc1v8_sys_s0";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&vcc1v8_sys_s3>;
+	};
+
+	vcc0v9_s3: vcc0v9-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc0v9_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <900000>;
+		regulator-max-microvolt = <900000>;
+		vin-supply = <&vcc3v3_sys_s3>;
+	};
+
+	avdd_0v9_s0: avdd-0v9-s0 {
+		compatible = "regulator-fixed";
+		regulator-name = "avdd_0v9_s0";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <900000>;
+		regulator-max-microvolt = <900000>;
+		vin-supply = <&vcc1v8_sys_s3>;
+	};
+
+	avdd_1v8_s0: avdd-1v8-s0 {
+		compatible = "regulator-fixed";
+		regulator-name = "avdd_1v8_s0";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&vcc3v3_sys_s3>;
+	};
+
+	pcie_power: pcie-power {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio1 RK_PD0 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pcie_pwr_en>;
+		regulator-name = "pcie_power";
+		regulator-boot-on;
+		startup-delay-us = <10000>;
+		vin-supply = <&vcc5v0_perdev>;
+	};
+
+	vcc3v3_sys_s3: vcc_lan: vcc3v3-sys-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_sys_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc5v0_sys>;
+
+		regulator-state-mem {
+			regulator-on-in-suspend;
+		};
+	};
+
+	vcc3v0_sd: vcc3v0-sd {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v0_sd";
+		regulator-boot-on;
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3000000>;
+		vin-supply = <&vcc3v3_sys_s3>;
+	};
+
+	vcc5v0_usb: vcc5v0-usb {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio1 RK_PC6 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_usb_en>;
+		regulator-name = "vcc5v0_usb";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc5v0_perdev>;
+	};
+
+	vcc5v0_typec: vcc5v0-typec-regulator {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio1 RK_PA3 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&fusb0_vbus_en>;
+		regulator-name = "vcc5v0_typec";
+		vin-supply = <&vcc5v0_usb>;
+	};
+
+	vcc5v0_perdev: vcc5v0-perdev {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_perdev";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin_bkup>;
+	};
+
+	vcc5v0_hdd: vcc5v0-hdd {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_hdd";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin_bkup>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin_bkup>;
+
+		regulator-state-mem {
+			regulator-on-in-suspend;
+		};
+	};
+
+	vdd_log: vdd-log {
+		compatible = "pwm-regulator";
+		pwms = <&pwm2 0 25000 1>;
+		regulator-name = "vdd_log";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <830000>;
+		regulator-max-microvolt = <1400000>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-state-mem {
+			regulator-on-in-suspend;
+			regulator-suspend-microvolt = <900000>;
+		};
+	};
+
+	power_hdd_a: power-hdd-a {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio1 RK_PA0 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&hdd_a_power>;
+		regulator-name = "power_hdd_a";
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	power_hdd_b: power-hdd-b {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio1 RK_PA1 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&hdd_b_power>;
+		regulator-name = "power_hdd_b";
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	usblan_power: usblan-power {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio1 RK_PC7 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usb_lan_en>;
+		regulator-name = "usblan_power";
+		regulator-always-on;
+		regulator-boot-on;
+		vin-supply = <&vcc5v0_usb>;
+	};
+
+	fan1: p7-fan {
+		compatible = "pwm-fan";
+		pwms = <&pwm0 0 40000 0>;
+		cooling-min-state = <0>;
+		cooling-max-state = <3>;
+		#cooling-cells = <2>;
+		cooling-levels = <0 80 170 255>;
+	};
+
+	fan2: p6-fan {
+		compatible = "pwm-fan";
+		pwms = <&pwm1 0 40000 0>;
+		cooling-min-state = <0>;
+		cooling-max-state = <3>;
+		#cooling-cells = <2>;
+		cooling-levels = <0 80 170 255>;
+	};
+
+	gpio-charger {
+		compatible = "gpio-charger";
+		charger-type = "mains";
+		gpios = <&gpio0 RK_PA2 GPIO_ACTIVE_HIGH>;
+		charge-status-gpios = <&gpio2 RK_PD3 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&ac_present_ap>, <&charger_status>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		autorepeat;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwrbtn>, <&user1btn>, <&wake_on_lan>;
+
+		power {
+			debounce-interval = <100>;
+			gpios = <&gpio0 RK_PA5 GPIO_ACTIVE_LOW>;
+			label = "Power";
+			linux,code = <KEY_POWER>;
+			wakeup-source;
+		};
+
+		user1-button {
+			debounce-interval = <100>;
+			gpios = <&gpio0 RK_PA3 GPIO_ACTIVE_LOW>;
+			label = "User Button 1";
+			linux,code = <BTN_0>;
+			wakeup-source;
+		};
+	};
+
+	hdmi_dp_sound: hdmi-dp-sound {
+		status = "okay";
+		compatible = "rockchip,rk3399-hdmi-dp";
+		rockchip,cpu = <&i2s2>;
+		rockchip,codec = <&cdn_dp>;
+	};
+
+	io_leds: io-gpio-leds {
+		status = "okay";
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&network_act>, <&usb3_act>,
+			<&sata_act>, <&sata_err_led>;
+
+		network	{
+			label = "helios64:blue:net";
+			gpios = <&gpio0 RK_PA4 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "netdev";
+			default-state = "off";
+		};
+
+		sata	{
+			label = "helios64:blue:hdd-status";
+			gpios = <&gpio4 RK_PD4 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "disk-activity";
+			default-state = "off";
+		};
+
+		sata_err1 {
+			label = "helios64:red:ata1-err";
+			gpios = <&gpio2 RK_PA2 GPIO_ACTIVE_HIGH>;
+			default-state = "keep";
+		};
+
+		sata_err2 {
+			label = "helios64:red:ata2-err";
+			gpios = <&gpio2 RK_PA3 GPIO_ACTIVE_HIGH>;
+			default-state = "keep";
+		};
+
+		sata_err3 {
+			label = "helios64:red:ata3-err";
+			gpios = <&gpio2 RK_PA4 GPIO_ACTIVE_HIGH>;
+			default-state = "keep";
+		};
+
+		sata_err4 {
+			label = "helios64:red:ata4-err";
+			gpios = <&gpio2 RK_PA5 GPIO_ACTIVE_HIGH>;
+			default-state = "keep";
+		};
+
+		sata_err5 {
+			label = "helios64:red:ata5-err";
+			gpios = <&gpio2 RK_PA6 GPIO_ACTIVE_HIGH>;
+			default-state = "keep";
+		};
+
+		usb3 {
+			label = "helios64:blue:usb3";
+			gpios = <&gpio0 RK_PB3 GPIO_ACTIVE_HIGH>;
+			trigger-sources = <&int_hub_port1>,
+					<&int_hub_port2>,
+					<&int_hub_port3>;
+			linux,default-trigger = "usbport";
+			default-state = "off";
+		};
+	};
+
+	pwmleds {
+		compatible = "pwm-leds";
+		status = "okay";
+
+		power-led {
+			label = "helios64:blue:power-status";
+			pwms = <&pwm3 0 2000000000 0>;
+			max-brightness = <255>;
+		};
+	};
+
+	system_leds: system-gpio-leds {
+		status = "okay";
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&system_led>;
+
+		status-led {
+			label = "helios64::status";
+			gpios = <&gpio0 RK_PB4 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+			default-state = "on";
+			mode = <0x23>;
+		};
+
+		fault-led {
+			label = "helios64:red:fault";
+			gpios = <&gpio0 RK_PB5 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "panic";
+			default-state = "keep";
+			mode = <0x23>;
+		};
+	};
+};
+
+&cdn_dp {
+	status = "okay";
+	extcon = <&fusb0>;
+	phys = <&tcphy0_dp>;
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_l1 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_l2 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_l3 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_b>;
+};
+
+&cpu_b1 {
+	cpu-supply = <&vdd_cpu_b>;
+};
+
+&emmc_phy {
+	status = "okay";
+};
+
+&gmac {
+	assigned-clocks = <&cru SCLK_RMII_SRC>;
+	assigned-clock-parents = <&clkin_gmac>;
+	clock_in_out = "input";
+	phy-supply = <&vcc_lan>;
+	phy-mode = "rgmii";
+	pinctrl-names = "default";
+	pinctrl-0 = <&rgmii_pins &rgmii_phy_reset>;
+	snps,reset-gpio = <&gpio3 RK_PB7 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	snps,reset-delays-us = <0 10000 50000>;
+	tx_delay = <0x28>;
+	rx_delay = <0x20>;
+	status = "okay";
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu>;
+	status = "okay";
+};
+
+&i2c0 {
+	clock-frequency = <400000>;
+	i2c-scl-rising-time-ns = <168>;
+	i2c-scl-falling-time-ns = <4>;
+	status = "okay";
+
+	rk808: pmic@1b {
+		compatible = "rockchip,rk808";
+		reg = <0x1b>;
+		#clock-cells = <1>;
+		clock-output-names = "xin32k", "rk808-clkout2";
+		interrupt-parent = <&gpio0>;
+		interrupts = <10 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pmic_int_l>;
+		rockchip,system-power-controller;
+		wakeup-source;
+
+		vcc1-supply = <&vcc5v0_sys>;
+		vcc2-supply = <&vcc5v0_sys>;
+		vcc3-supply = <&vcc5v0_sys>;
+		vcc4-supply = <&vcc5v0_sys>;
+		vcc6-supply = <&vcc5v0_sys>;
+		vcc7-supply = <&vcc5v0_sys>;
+		vcc8-supply = <&vcc3v3_sys_s3>;
+		vcc9-supply = <&vcc5v0_sys>;
+		vcc10-supply = <&vcc5v0_sys>;
+		vcc11-supply = <&vcc5v0_sys>;
+		vcc12-supply = <&vcc3v3_sys_s3>;
+		vddio-supply = <&vcc3v0_s3>;
+
+		regulators {
+			vdd_center: DCDC_REG1 {
+				regulator-name = "vdd_center";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1000000>;
+				regulator-ramp-delay = <6001>;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <950000>;
+				};
+			};
+
+			vdd_cpu_l: DCDC_REG2 {
+				regulator-name = "vdd_cpu_l";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-ramp-delay = <6001>;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_ddr_s3: DCDC_REG3 {
+				regulator-name = "vcc_ddr_s3";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vcc1v8_sys_s3: DCDC_REG4 {
+				regulator-name = "vcc1v8_sys_s3";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			/* not used */
+			vcc1v8_dvp: LDO_REG1 {
+				regulator-name = "vcc1v8_dvp";
+			};
+
+			/* not used */
+			vcc3v0_touch: LDO_REG2 {
+				regulator-name = "vcc3v0_touch";
+			};
+
+			vcc1v8_s3: LDO_REG3 {
+				regulator-name = "vcc1v8_s3";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vcc_sdio_s0: LDO_REG4 {
+				regulator-name = "vcc_sdio_s0";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3000000>;
+				};
+			};
+
+			/* not used */
+			vcca3v0_codec: LDO_REG5 {
+				regulator-name = "vcca3v0_codec";
+			};
+
+			vcc1v5_s3: LDO_REG6 {
+				regulator-name = "vcc1v5_s3";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1500000>;
+				};
+			};
+
+			/* not used */
+			vcca1v8_codec: LDO_REG7 {
+				regulator-name = "vcca1v8_codec";
+			};
+
+			vcc3v0_s3: LDO_REG8 {
+				regulator-name = "vcc3v0_s3";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3000000>;
+				};
+			};
+
+			vcc3v3_sys_s0: SWITCH_REG1 {
+				regulator-name = "vcc3v3_sys_s0";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			/* not used */
+			vcc3v3_s0: SWITCH_REG2 {
+				regulator-name = "vcc3v3_s0";
+			};
+		};
+	};
+
+	vdd_cpu_b: regulator@40 {
+		compatible = "silergy,syr827";
+		reg = <0x40>;
+		fcs,suspend-voltage-selector = <1>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vsel1_gpio>;
+		regulator-name = "vdd_cpu_b";
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1500000>;
+		regulator-ramp-delay = <40000>;
+		regulator-always-on;
+		regulator-boot-on;
+		vin-supply = <&vcc5v0_sys>;
+
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_gpu: regulator@41 {
+		compatible = "silergy,syr828";
+		reg = <0x41>;
+		fcs,suspend-voltage-selector = <1>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vsel2_gpio>;
+		regulator-name = "vdd_gpu";
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1500000>;
+		regulator-ramp-delay = <1000>;
+		regulator-always-on;
+		regulator-boot-on;
+		vin-supply = <&vcc5v0_sys>;
+
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c2 {
+	clock-frequency = <400000>;
+	i2c-scl-rising-time-ns = <160>;
+	i2c-scl-falling-time-ns = <30>;
+	status = "okay";
+
+	gpio-expander@20 {
+		compatible = "nxp,pca9555";
+		reg = <0x20>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pca0_pins>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <9 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		vcc-supply = <&vcc3v3_sys_s3>;
+	};
+
+	temp@4c {
+		compatible = "onnn,lm75";
+		reg = <0x4c>;
+	};
+};
+
+&i2c4 {
+	clock-frequency = <400000>;
+	i2c-scl-rising-time-ns = <160>;
+	i2c-scl-falling-time-ns = <30>;
+	status = "okay";
+
+	fusb0: typec-portc@22 {
+		compatible = "fcs,fusb302";
+		reg = <0x22>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <RK_PA2 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&fusb0_int>;
+		vbus-supply = <&vcc5v0_typec>;
+
+		connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			power-role = "dual";
+			data-role = "dual";
+			try-power-role = "sink";
+			source-pdos = <PDO_FIXED(5000, 1200, PDO_FIXED_USB_COMM)>;
+			sink-pdos = <PDO_FIXED(5000, 500, PDO_FIXED_USB_COMM)>;
+			op-sink-microwatt = <5000000>;
+
+			extcon-cables = <1 2 5 6 9 10 12 44>;
+			typec-altmodes = <0xff01 1 0x001c0000 1>;
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					usb_con_hs: endpoint {
+						remote-endpoint = <&u2phy0_typec_hs>;
+					};
+				};
+				port@1 {
+					reg = <1>;
+					usb_con_ss: endpoint {
+						remote-endpoint = <&tcphy0_typec_ss>;
+					};
+				};
+				port@2 {
+					reg = <2>;
+					usb_con_sbu: endpoint {
+						remote-endpoint = <&tcphy0_typec_dp>;
+					};
+				};
+			};
+		};
+	};
+};
+
+/* I2C on UEXT */
+&i2c7 {
+	status = "okay";
+};
+
+/* External I2C */
+&i2c8 {
+	status = "okay";
+};
+
+&i2s2 {
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&io_domains {
+	status = "okay";
+	bt656-supply = <&vcc1v8_sys_s0>;
+	audio-supply = <&vcc1v8_sys_s0>;
+	sdmmc-supply = <&vcc_sdio_s0>;
+	gpio1830-supply = <&vcc3v0_s3>;
+};
+
+&pcie0 {
+	ep-gpios = <&gpio2 RK_PD4 GPIO_ACTIVE_HIGH>;
+	num-lanes = <2>;
+	max-link-speed = <2>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pcie_prst &pcie_clkreqn_cpm>;
+	vpcie12v-supply = <&vcc12v_dcin>;
+	vpcie3v3-supply = <&pcie_power>;
+	vpcie1v8-supply = <&avdd_1v8_s0>;
+	vpcie0v9-supply = <&avdd_0v9_s0>;
+	status = "okay";
+};
+
+&pcie_phy {
+	status = "okay";
+};
+
+&pinctrl {
+	buttons {
+		pwrbtn: pwrbtn {
+			rockchip,pins = <0 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		user1btn: usr1btn {
+			rockchip,pins = <0 RK_PA3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	charger {
+		ac_present_ap: ac-present-ap {
+			rockchip,pins = <0 RK_PA2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		charger_status: charger-status {
+			rockchip,pins = <2 RK_PD3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	fan {
+		fan1_sense: fan1-sense {
+			rockchip,pins = <4 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		fan2_sense: fan2-sense {
+			rockchip,pins = <4 RK_PC7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	fusb30x {
+		fusb0_int: fusb0-int {
+			rockchip,pins =
+				<1 RK_PA2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		fusb0_vbus_en: fusb0-vbus-en {
+			rockchip,pins =
+				<1 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	gmac {
+		rgmii_phy_reset: rgmii-phy-reset {
+			rockchip,pins =
+				<3 RK_PB7 RK_FUNC_GPIO &pcfg_output_low>;
+		};
+	};
+
+	leds {
+		network_act: network-act {
+			rockchip,pins =
+				<0 RK_PA4 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		usb3_act: usb3-act {
+			rockchip,pins =
+				<0 RK_PB3 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		sata_act: sata-act {
+			rockchip,pins =
+				<4 RK_PD4 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		system_led: sys-led {
+			rockchip,pins =
+				<0 RK_PB4 RK_FUNC_GPIO &pcfg_pull_down>,
+				<0 RK_PB5 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		sata_err_led: sata-err-led {
+			rockchip,pins =
+				<2 RK_PA2 RK_FUNC_GPIO &pcfg_pull_down>,
+				<2 RK_PA3 RK_FUNC_GPIO &pcfg_pull_down>,
+				<2 RK_PA4 RK_FUNC_GPIO &pcfg_pull_down>,
+				<2 RK_PA5 RK_FUNC_GPIO &pcfg_pull_down>,
+				<2 RK_PA6 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	misc {
+		pca0_pins: pca0-pins {
+			rockchip,pins =
+				<0 RK_PB1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		wake_on_lan: wake-on-lan {
+			rockchip,pins =
+				<0 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	pcie {
+		pcie_prst: pcie-prst {
+			rockchip,pins =
+				<2 RK_PD4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		pcie_pwr_en: pcie-pwr-en {
+			rockchip,pins =
+				<1 RK_PD0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	pmic {
+		pmic_int_l: pmic-int-l {
+			rockchip,pins =
+				<0 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		vsel1_gpio: vsel1-gpio {
+			rockchip,pins =
+				<1 RK_PC1 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		vsel2_gpio: vsel2-gpio {
+			rockchip,pins =
+				<1 RK_PB6 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	power  {
+		hdd_a_power: hdd-a-power {
+			rockchip,pins =
+				<1 RK_PA0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		hdd_b_power: hdd-b-power {
+			rockchip,pins =
+				<1 RK_PA1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		vcc5v0_usb_en: vcc5v0-usb-en {
+			rockchip,pins =
+				<1 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		sdmmc0_pwr_h: sdmmc0-pwr-h {
+			rockchip,pins =
+				<0 RK_PA1 RK_FUNC_GPIO &pcfg_output_high>;
+		};
+
+		usb_lan_en: usb-lan-en {
+			rockchip,pins =
+				<1 RK_PC7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
+
+&pmu_io_domains {
+	pmu1830-supply = <&vcc3v0_s3>;
+	status = "okay";
+};
+
+&pwm0 {
+	status = "okay";
+};
+
+&pwm1 {
+	status = "okay";
+};
+
+&pwm2 {
+	status = "okay";
+};
+
+&pwm3 {
+	status = "okay";
+};
+
+&saradc {
+	vref-supply = <&vcc1v8_s3>;
+	status = "okay";
+};
+
+&sdhci {
+	assigned-clock-rates = <150000000>;
+	bus-width = <8>;
+	mmc-hs200-1_8v;
+	// hs400 is broken on Helios64 since 5.10.60
+	// mmc-hs400-1_8v;
+	// mmc-hs400-enhanced-strobe;
+	supports-emmc;
+	non-removable;
+	disable-wp;
+	status = "okay";
+	vqmmc-supply = <&vcc1v8_sys_s0>;
+};
+
+&sdmmc {
+	bus-width = <4>;
+	cap-sd-highspeed;
+	cd-gpios = <&gpio0 RK_PA7 GPIO_ACTIVE_LOW>; // TODO: verify what needs to be done to use implicit CD definition
+	disable-wp;
+	sd-uhs-sdr104;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc_clk &sdmmc_cmd &sdmmc_cd &sdmmc_bus4>;
+	vmmc-supply = <&vcc3v0_sd>;
+	vqmmc-supply = <&vcc_sdio_s0>;
+	status = "okay";
+};
+
+&spi1 {
+	status = "okay";
+};
+
+/* UEXT connector */
+&spi2 {
+	status = "okay";
+};
+
+&spi5 {
+	status = "okay";
+};
+
+&tcphy0 {
+	extcon = <&fusb0>;
+	status = "okay";
+};
+
+&tcphy0_dp {
+	port {
+		tcphy0_typec_dp: endpoint {
+			remote-endpoint = <&usb_con_sbu>;
+		};
+	};
+};
+
+&tcphy0_usb3 {
+	port {
+		tcphy0_typec_ss: endpoint {
+			remote-endpoint = <&usb_con_ss>;
+		};
+	};
+};
+
+&tcphy1 {
+	status = "okay";
+};
+
+&tsadc {
+	/* tshut mode 0:CRU 1:GPIO */
+	rockchip,hw-tshut-mode = <1>;
+	/* tshut polarity 0:LOW 1:HIGH */
+	rockchip,hw-tshut-polarity = <1>;
+	status = "okay";
+};
+
+&u2phy0 {
+	status = "okay";
+
+	u2phy0_otg: otg-port {
+		status = "okay";
+	};
+
+	u2phy0_host: host-port {
+		phy-supply = <&vcc5v0_usb>;
+		status = "okay";
+	};
+
+	port {
+		u2phy0_typec_hs: endpoint {
+			remote-endpoint = <&usb_con_hs>;
+		};
+	};
+};
+
+&u2phy1 {
+	status = "okay";
+
+	u2phy1_otg: otg-port {
+		status = "okay";
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_xfer>;
+	status = "okay";
+};
+
+&uart2 {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	status = "okay";
+	dr_mode = "otg";
+};
+
+&usbdrd3_1 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_1 {
+	status = "okay";
+	dr_mode = "host";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	int_hub: hub@1 {
+		compatible = "usb2109,0815";
+		reg = <1>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		int_hub_port1: port@1 {
+			reg = <1>;
+			#trigger-source-cells = <0>;
+		};
+
+		int_hub_port2: port@2 {
+			reg = <2>;
+			#trigger-source-cells = <0>;
+		};
+
+		int_hub_port3: port@3 {
+			reg = <3>;
+			#trigger-source-cells = <0>;
+		};
+
+		usb_lan: device@4 {
+			compatible = "usbbda,8156";
+			reg = <4>;
+
+			#address-cells = <2>;
+			#size-cells = <0>;
+
+			interface@0 {	/* interface 0 of configuration 1 */
+				compatible = "usbbda,8156.config1.0";
+				reg = <0 1>;
+			};
+		};
+	};
+};
+
+&vopb {
+	status = "okay";
+};
+
+&vopb_mmu {
+	status = "okay";
+};
+
+&vopl {
+	status = "okay";
+};
+
+&vopl_mmu {
+	status = "okay";
+};
\ No newline at end of file
-- 
2.32.0


From 211ced8c6c87d4a05380de37229eb37d0cc4ab74 Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:21 -0400
Subject: [PATCH 02/26] [armbian] add-boards-to-dts-makefile.patch

---
 arch/arm64/boot/dts/rockchip/Makefile | 1 +
 1 file changed, 1 insertion(+)

diff --git a/arch/arm64/boot/dts/rockchip/Makefile b/arch/arm64/boot/dts/rockchip/Makefile
index 26661c7b736b7..aa19b913049d0 100644
--- a/arch/arm64/boot/dts/rockchip/Makefile
+++ b/arch/arm64/boot/dts/rockchip/Makefile
@@ -1,4 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-kobol-helios64.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += px30-evb.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3308-evb.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3308-roc-cc.dtb
-- 
2.32.0


From d633b6c9097e60f2accf1dbaaaef75da5a34981f Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:21 -0400
Subject: [PATCH 03/26] [armbian] add-csgpio-to-rockchip-spi.patch

---
 drivers/spi/spi-rockchip.c | 51 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 51 insertions(+)

diff --git a/drivers/spi/spi-rockchip.c b/drivers/spi/spi-rockchip.c
index 0aab37cd64e74..4aa6f865d4524 100644
--- a/drivers/spi/spi-rockchip.c
+++ b/drivers/spi/spi-rockchip.c
@@ -6,6 +6,7 @@
 
 #include <linux/clk.h>
 #include <linux/dmaengine.h>
+#include <linux/gpio.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/of.h>
@@ -190,6 +191,10 @@ struct rockchip_spi {
 	bool slave_abort;
 };
 
+struct rockchip_spi_data {
+       bool cs_gpio_requested;
+};
+
 static inline void spi_enable_chip(struct rockchip_spi *rs, bool enable)
 {
 	writel_relaxed((enable ? 1U : 0U), rs->regs + ROCKCHIP_SPI_SSIENR);
@@ -474,6 +479,50 @@ static int rockchip_spi_prepare_dma(struct rockchip_spi *rs,
 	return 1;
 }
 
+static int rockchip_spi_setup(struct spi_device *spi)
+{
+	int ret = 0;
+	unsigned long flags = (spi->mode & SPI_CS_HIGH) ?
+			      GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH;
+	struct rockchip_spi_data *data = spi_get_ctldata(spi);
+
+	if (!gpio_is_valid(spi->cs_gpio))
+		return 0;
+
+	if (!data) {
+		data = kzalloc(sizeof(*data), GFP_KERNEL);
+		if (!data)
+			return -ENOMEM;
+		spi_set_ctldata(spi, data);
+	}
+
+	if (!data->cs_gpio_requested) {
+		ret = gpio_request_one(spi->cs_gpio, flags,
+				       dev_name(&spi->dev));
+		if (!ret)
+			data->cs_gpio_requested = 1;
+	} else
+		ret = gpio_direction_output(spi->cs_gpio, flags);
+
+	if (ret < 0)
+		dev_err(&spi->dev, "Failed to setup cs gpio(%d): %d\n",
+			spi->cs_gpio, ret);
+
+	return ret;
+}
+
+static void rockchip_spi_cleanup(struct spi_device *spi)
+{
+	struct rockchip_spi_data *data = spi_get_ctldata(spi);
+
+	if (data) {
+		if (data->cs_gpio_requested)
+			gpio_free(spi->cs_gpio);
+		kfree(data);
+		spi_set_ctldata(spi, NULL);
+	}
+}
+
 static int rockchip_spi_config(struct rockchip_spi *rs,
 		struct spi_device *spi, struct spi_transfer *xfer,
 		bool use_dma, bool slave_mode)
@@ -748,6 +797,8 @@ static int rockchip_spi_probe(struct platform_device *pdev)
 	ctlr->max_speed_hz = min(rs->freq / BAUDR_SCKDV_MIN, MAX_SCLK_OUT);
 
 	ctlr->set_cs = rockchip_spi_set_cs;
+	ctlr->setup = rockchip_spi_setup;
+	ctlr->cleanup = rockchip_spi_cleanup;
 	ctlr->transfer_one = rockchip_spi_transfer_one;
 	ctlr->max_transfer_size = rockchip_spi_max_transfer_size;
 	ctlr->handle_err = rockchip_spi_handle_err;
-- 
2.32.0


From 456ed338e4d8d49d637b5a4a9407521551dfc671 Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:21 -0400
Subject: [PATCH 04/26] [armbian] add-fusb30x-driver.patch

---
 drivers/staging/Kconfig           |    2 +
 drivers/staging/Makefile          |    1 +
 drivers/staging/fusb30x/Kconfig   |   10 +
 drivers/staging/fusb30x/Makefile  |    2 +
 drivers/staging/fusb30x/fusb30x.c | 3434 +++++++++++++++++++++++++++++
 drivers/staging/fusb30x/fusb30x.h |  552 +++++
 6 files changed, 4001 insertions(+)
 create mode 100644 drivers/staging/fusb30x/Kconfig
 create mode 100644 drivers/staging/fusb30x/Makefile
 create mode 100644 drivers/staging/fusb30x/fusb30x.c
 create mode 100644 drivers/staging/fusb30x/fusb30x.h

diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index 2d0310448eba0..6545f7cd94de4 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -82,6 +82,8 @@ source "drivers/staging/fbtft/Kconfig"
 
 source "drivers/staging/fsl-dpaa2/Kconfig"
 
+source "drivers/staging/fusb30x/Kconfig"
+
 source "drivers/staging/most/Kconfig"
 
 source "drivers/staging/ks7010/Kconfig"
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index 757a892ab5b9a..3652b0bbd7467 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -31,6 +31,7 @@ obj-$(CONFIG_UNISYSSPAR)	+= unisys/
 obj-$(CONFIG_COMMON_CLK_XLNX_CLKWZRD)	+= clocking-wizard/
 obj-$(CONFIG_FB_TFT)		+= fbtft/
 obj-$(CONFIG_FSL_DPAA2)		+= fsl-dpaa2/
+obj-$(CONFIG_FUSB_30X)		+= fusb30x/
 obj-$(CONFIG_MOST)		+= most/
 obj-$(CONFIG_KS7010)		+= ks7010/
 obj-$(CONFIG_GREYBUS)		+= greybus/
diff --git a/drivers/staging/fusb30x/Kconfig b/drivers/staging/fusb30x/Kconfig
new file mode 100644
index 0000000000000..5bb75270f5786
--- /dev/null
+++ b/drivers/staging/fusb30x/Kconfig
@@ -0,0 +1,10 @@
+config FUSB_30X
+	tristate "Fairchild FUSB30X Type-C chip driver"
+	depends on I2C
+	help
+	  This is a driver for the Fairchild FUSB302 Type-C chip.  It supports
+	  USB Type-C PD functionality controlled using I2C.
+
+	  This driver supports extcon reporting not yet implemented in the
+	  mainline FUSB302 driver.
+
diff --git a/drivers/staging/fusb30x/Makefile b/drivers/staging/fusb30x/Makefile
new file mode 100644
index 0000000000000..1c8e35df3d203
--- /dev/null
+++ b/drivers/staging/fusb30x/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_FUSB_30X)	+= fusb30x.o
diff --git a/drivers/staging/fusb30x/fusb30x.c b/drivers/staging/fusb30x/fusb30x.c
new file mode 100644
index 0000000000000..56d22648cfb1b
--- /dev/null
+++ b/drivers/staging/fusb30x/fusb30x.c
@@ -0,0 +1,3434 @@
+/*
+ * Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Zain Wang <zain.wang@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * Some ideas are from chrome ec and fairchild GPL fusb302 driver.
+ */
+
+#include <linux/delay.h>
+#include <linux/extcon.h>
+#include <linux/extcon-provider.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <linux/power_supply.h>
+
+#include "fusb30x.h"
+
+#define FUSB302_MAX_REG		(FUSB_REG_FIFO + 50)
+#define FUSB_MS_TO_NS(x)	((s64)x * 1000 * 1000)
+
+#define TYPEC_CC_VOLT_OPEN	0
+#define TYPEC_CC_VOLT_RA	1
+#define TYPEC_CC_VOLT_RD	2
+#define TYPEC_CC_VOLT_RP	3
+
+#define EVENT_CC		BIT(0)
+#define EVENT_RX		BIT(1)
+#define EVENT_TX		BIT(2)
+#define EVENT_REC_RESET		BIT(3)
+#define EVENT_WORK_CONTINUE	BIT(5)
+#define EVENT_TIMER_MUX		BIT(6)
+#define EVENT_TIMER_STATE	BIT(7)
+#define EVENT_DELAY_CC		BIT(8)
+#define FLAG_EVENT		(EVENT_RX | EVENT_TIMER_MUX | \
+				 EVENT_TIMER_STATE)
+
+#define PACKET_IS_CONTROL_MSG(header, type) \
+		(PD_HEADER_CNT(header) == 0 && \
+		 PD_HEADER_TYPE(header) == type)
+
+#define PACKET_IS_DATA_MSG(header, type) \
+		(PD_HEADER_CNT(header) != 0 && \
+		 PD_HEADER_TYPE(header) == type)
+
+/*
+ * DisplayPort modes capabilities
+ * -------------------------------
+ * <31:24> : Reserved (always 0).
+ * <23:16> : UFP_D pin assignment supported
+ * <15:8>  : DFP_D pin assignment supported
+ * <7>     : USB 2.0 signaling (0b=yes, 1b=no)
+ * <6>     : Plug | Receptacle (0b == plug, 1b == receptacle)
+ * <5:2>   : xxx1: Supports DPv1.3, xx1x Supports USB Gen 2 signaling
+ *	     Other bits are reserved.
+ * <1:0>   : signal direction ( 00b=rsv, 01b=sink, 10b=src 11b=both )
+ */
+#define PD_DP_PIN_CAPS(x)	((((x) >> 6) & 0x1) ? (((x) >> 16) & 0x3f) \
+				 : (((x) >> 8) & 0x3f))
+#define PD_DP_SIGNAL_GEN2(x)	(((x) >> 3) & 0x1)
+
+#define MODE_DP_PIN_A		BIT(0)
+#define MODE_DP_PIN_B		BIT(1)
+#define MODE_DP_PIN_C		BIT(2)
+#define MODE_DP_PIN_D		BIT(3)
+#define MODE_DP_PIN_E		BIT(4)
+#define MODE_DP_PIN_F		BIT(5)
+
+/* Pin configs B/D/F support multi-function */
+#define MODE_DP_PIN_MF_MASK	(MODE_DP_PIN_B | MODE_DP_PIN_D | MODE_DP_PIN_F)
+/* Pin configs A/B support BR2 signaling levels */
+#define MODE_DP_PIN_BR2_MASK	(MODE_DP_PIN_A | MODE_DP_PIN_B)
+/* Pin configs C/D/E/F support DP signaling levels */
+#define MODE_DP_PIN_DP_MASK	(MODE_DP_PIN_C | MODE_DP_PIN_D | \
+				 MODE_DP_PIN_E | MODE_DP_PIN_F)
+
+/*
+ * DisplayPort Status VDO
+ * ----------------------
+ * <31:9> : Reserved (always 0).
+ * <8>    : IRQ_HPD : 1 == irq arrived since last message otherwise 0.
+ * <7>    : HPD state : 0 = HPD_LOW, 1 == HPD_HIGH
+ * <6>    : Exit DP Alt mode: 0 == maintain, 1 == exit
+ * <5>    : USB config : 0 == maintain current, 1 == switch to USB from DP
+ * <4>    : Multi-function preference : 0 == no pref, 1 == MF preferred.
+ * <3>    : enabled : is DPout on/off.
+ * <2>    : power low : 0 == normal or LPM disabled, 1 == DP disabled for LPM
+ * <1:0>  : connect status : 00b ==  no (DFP|UFP)_D is connected or disabled.
+ *	    01b == DFP_D connected, 10b == UFP_D connected, 11b == both.
+ */
+#define PD_VDO_DPSTS_HPD_IRQ(x)	(((x) >> 8) & 0x1)
+#define PD_VDO_DPSTS_HPD_LVL(x)	(((x) >> 7) & 0x1)
+#define PD_VDO_DPSTS_MF_PREF(x)	(((x) >> 4) & 0x1)
+
+static u8 fusb30x_port_used;
+static struct fusb30x_chip *fusb30x_port_info[256];
+
+static bool is_write_reg(struct device *dev, unsigned int reg)
+{
+	if (reg >= FUSB_REG_FIFO)
+		return true;
+	else
+		return ((reg < (FUSB_REG_CONTROL4 + 1)) && (reg > 0x01)) ?
+			true : false;
+}
+
+static bool is_volatile_reg(struct device *dev, unsigned int reg)
+{
+	if (reg > FUSB_REG_CONTROL4)
+		return true;
+
+	switch (reg) {
+	case FUSB_REG_CONTROL0:
+	case FUSB_REG_CONTROL1:
+	case FUSB_REG_CONTROL3:
+	case FUSB_REG_RESET:
+		return true;
+	}
+	return false;
+}
+
+struct regmap_config fusb302_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.writeable_reg = is_write_reg,
+	.volatile_reg = is_volatile_reg,
+	.max_register = FUSB302_MAX_REG,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static void dump_notify_info(struct fusb30x_chip *chip)
+{
+	dev_dbg(chip->dev, "port        %d\n", chip->port_num);
+	dev_dbg(chip->dev, "orientation %d\n", chip->notify.orientation);
+	dev_dbg(chip->dev, "power_role  %d\n", chip->notify.power_role);
+	dev_dbg(chip->dev, "data_role   %d\n", chip->notify.data_role);
+	dev_dbg(chip->dev, "cc          %d\n", chip->notify.is_cc_connected);
+	dev_dbg(chip->dev, "pd          %d\n", chip->notify.is_pd_connected);
+	dev_dbg(chip->dev, "enter_mode  %d\n", chip->notify.is_enter_mode);
+	dev_dbg(chip->dev, "pin support %d\n",
+		chip->notify.pin_assignment_support);
+	dev_dbg(chip->dev, "pin def     %d\n", chip->notify.pin_assignment_def);
+	dev_dbg(chip->dev, "attention   %d\n", chip->notify.attention);
+}
+
+static const unsigned int fusb302_cable[] = {
+	EXTCON_USB,
+	EXTCON_USB_HOST,
+	EXTCON_CHG_USB_SDP,
+	EXTCON_CHG_USB_CDP,
+	EXTCON_CHG_USB_DCP,
+	EXTCON_CHG_USB_SLOW,
+	EXTCON_CHG_USB_FAST,
+	EXTCON_DISP_DP,
+	EXTCON_NONE,
+};
+
+static void fusb_set_pos_power(struct fusb30x_chip *chip, int max_vol,
+			       int max_cur)
+{
+	int i;
+	int pos_find;
+	int tmp;
+
+	pos_find = 0;
+	for (i = PD_HEADER_CNT(chip->rec_head) - 1; i >= 0; i--) {
+		switch (CAP_POWER_TYPE(chip->rec_load[i])) {
+		case 0:
+			/* Fixed Supply */
+			if ((CAP_FPDO_VOLTAGE(chip->rec_load[i]) * 50) <=
+			    max_vol &&
+			    (CAP_FPDO_CURRENT(chip->rec_load[i]) * 10) <=
+			    max_cur) {
+				chip->pos_power = i + 1;
+				tmp = CAP_FPDO_VOLTAGE(chip->rec_load[i]);
+				chip->pd_output_vol = tmp * 50;
+				tmp = CAP_FPDO_CURRENT(chip->rec_load[i]);
+				chip->pd_output_cur = tmp * 10;
+				pos_find = 1;
+			}
+			break;
+		case 1:
+			/* Battery */
+			if ((CAP_VPDO_VOLTAGE(chip->rec_load[i]) * 50) <=
+			    max_vol &&
+			    (CAP_VPDO_CURRENT(chip->rec_load[i]) * 10) <=
+			    max_cur) {
+				chip->pos_power = i + 1;
+				tmp = CAP_VPDO_VOLTAGE(chip->rec_load[i]);
+				chip->pd_output_vol = tmp * 50;
+				tmp = CAP_VPDO_CURRENT(chip->rec_load[i]);
+				chip->pd_output_cur = tmp * 10;
+				pos_find = 1;
+			}
+			break;
+		default:
+			/* not meet battery caps */
+			break;
+		}
+		if (pos_find)
+			break;
+	}
+}
+
+static int fusb302_set_pos_power_by_charge_ic(struct fusb30x_chip *chip)
+{
+	struct power_supply *psy = NULL;
+	union power_supply_propval val;
+	enum power_supply_property psp;
+	int max_vol, max_cur;
+
+	max_vol = 0;
+	max_cur = 0;
+	psy = power_supply_get_by_phandle(chip->dev->of_node, "charge-dev");
+	if (!psy || IS_ERR(psy))
+		return -1;
+
+	psp = POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX;
+	if (power_supply_get_property(psy, psp, &val) == 0)
+		max_vol = val.intval / 1000;
+
+	psp = POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT;
+	if (power_supply_get_property(psy, psp, &val) == 0)
+		max_cur = val.intval / 1000;
+
+	if (max_vol > 0 && max_cur > 0)
+		fusb_set_pos_power(chip, max_vol, max_cur);
+
+	return 0;
+}
+
+void fusb_irq_disable(struct fusb30x_chip *chip)
+{
+	unsigned long irqflags = 0;
+
+	spin_lock_irqsave(&chip->irq_lock, irqflags);
+	if (chip->enable_irq) {
+		disable_irq_nosync(chip->gpio_int_irq);
+		chip->enable_irq = 0;
+	} else {
+		dev_warn(chip->dev, "irq have already disabled\n");
+	}
+	spin_unlock_irqrestore(&chip->irq_lock, irqflags);
+}
+
+void fusb_irq_enable(struct fusb30x_chip *chip)
+{
+	unsigned long irqflags = 0;
+
+	spin_lock_irqsave(&chip->irq_lock, irqflags);
+	if (!chip->enable_irq) {
+		enable_irq(chip->gpio_int_irq);
+		chip->enable_irq = 1;
+	}
+	spin_unlock_irqrestore(&chip->irq_lock, irqflags);
+}
+
+static void platform_fusb_notify(struct fusb30x_chip *chip)
+{
+	bool plugged = false, flip = false, dfp = false, ufp = false,
+	     dp = false, usb_ss = false, hpd = false;
+	union extcon_property_value property;
+
+	if (chip->notify.is_cc_connected)
+		chip->notify.orientation =
+			(chip->cc_polarity == TYPEC_POLARITY_CC1) ?
+			CC1 : CC2;
+
+	/* avoid notify repeated */
+	if (memcmp(&chip->notify, &chip->notify_cmp,
+		   sizeof(struct notify_info))) {
+		dump_notify_info(chip);
+		chip->notify.attention = false;
+		memcpy(&chip->notify_cmp, &chip->notify,
+		       sizeof(struct notify_info));
+
+		plugged = chip->notify.is_cc_connected ||
+			  chip->notify.is_pd_connected;
+		if (chip->notify.orientation != NONE)
+			flip = (chip->notify.orientation == CC1) ? false : true;
+		dp = chip->notify.is_enter_mode;
+
+		if (dp) {
+			dfp = true;
+			usb_ss = (chip->notify.pin_assignment_def &
+				  MODE_DP_PIN_MF_MASK) ? true : false;
+			hpd = GET_DP_STATUS_HPD(chip->notify.dp_status);
+		} else if (chip->notify.data_role) {
+			dfp = true;
+			usb_ss = true;
+		} else if (plugged) {
+			ufp = true;
+			usb_ss = true;
+		}
+
+		property.intval = flip;
+		extcon_set_property(chip->extcon, EXTCON_USB,
+				    EXTCON_PROP_USB_TYPEC_POLARITY, property);
+		extcon_set_property(chip->extcon, EXTCON_USB_HOST,
+				    EXTCON_PROP_USB_TYPEC_POLARITY, property);
+		extcon_set_property(chip->extcon, EXTCON_DISP_DP,
+				    EXTCON_PROP_USB_TYPEC_POLARITY, property);
+
+		property.intval = usb_ss;
+		extcon_set_property(chip->extcon, EXTCON_USB,
+				    EXTCON_PROP_USB_SS, property);
+		extcon_set_property(chip->extcon, EXTCON_USB_HOST,
+				    EXTCON_PROP_USB_SS, property);
+		extcon_set_property(chip->extcon, EXTCON_DISP_DP,
+				    EXTCON_PROP_USB_SS, property);
+		extcon_set_state(chip->extcon, EXTCON_USB, ufp);
+		extcon_set_state(chip->extcon, EXTCON_USB_HOST, dfp);
+		extcon_set_state(chip->extcon, EXTCON_DISP_DP, dp && hpd);
+		extcon_sync(chip->extcon, EXTCON_USB);
+		extcon_sync(chip->extcon, EXTCON_USB_HOST);
+		extcon_sync(chip->extcon, EXTCON_DISP_DP);
+		if (chip->notify.power_role == POWER_ROLE_SINK &&
+		    chip->notify.is_pd_connected &&
+		    chip->pd_output_vol > 0 && chip->pd_output_cur > 0) {
+			extcon_set_state(chip->extcon, EXTCON_CHG_USB_FAST, true);
+			property.intval =
+				(chip->pd_output_cur << 15 |
+				 chip->pd_output_vol);
+			extcon_set_property(chip->extcon, EXTCON_CHG_USB_FAST,
+					    EXTCON_PROP_USB_TYPEC_POLARITY,
+					    property);
+			extcon_sync(chip->extcon, EXTCON_CHG_USB_FAST);
+		}
+	}
+}
+
+static bool platform_get_device_irq_state(struct fusb30x_chip *chip)
+{
+	return !gpiod_get_value(chip->gpio_int);
+}
+
+static void fusb_timer_start(struct hrtimer *timer, int ms)
+{
+	ktime_t ktime;
+
+	ktime = ktime_set(0, FUSB_MS_TO_NS(ms));
+	hrtimer_start(timer, ktime, HRTIMER_MODE_REL);
+}
+
+static void platform_set_vbus_lvl_enable(struct fusb30x_chip *chip, int vbus_5v,
+					 int vbus_other)
+{
+	bool gpio_vbus_value = false;
+
+	gpio_vbus_value = gpiod_get_value(chip->gpio_vbus_5v);
+	if (chip->gpio_vbus_5v) {
+		gpiod_set_raw_value(chip->gpio_vbus_5v, vbus_5v);
+	}
+
+	if (chip->gpio_vbus_other)
+		gpiod_set_raw_value(chip->gpio_vbus_5v, vbus_other);
+
+	if (chip->gpio_discharge && !vbus_5v && gpio_vbus_value) {
+		gpiod_set_value(chip->gpio_discharge, 1);
+		msleep(20);
+		gpiod_set_value(chip->gpio_discharge, 0);
+	}
+}
+
+static void set_state(struct fusb30x_chip *chip, enum connection_state state)
+{
+	dev_dbg(chip->dev, "port %d, state %d\n", chip->port_num, state);
+	if (!state)
+		dev_info(chip->dev, "PD disabled\n");
+	chip->conn_state = state;
+	chip->sub_state = 0;
+	chip->val_tmp = 0;
+	chip->work_continue |= EVENT_WORK_CONTINUE;
+}
+
+static int tcpm_get_message(struct fusb30x_chip *chip)
+{
+	u8 buf[32];
+	int len;
+
+	do {
+		regmap_raw_read(chip->regmap, FUSB_REG_FIFO, buf, 3);
+		chip->rec_head = (buf[1] & 0xff) | ((buf[2] << 8) & 0xff00);
+
+		len = PD_HEADER_CNT(chip->rec_head) << 2;
+		regmap_raw_read(chip->regmap, FUSB_REG_FIFO, buf, len + 4);
+	/* ignore good_crc message */
+	} while (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_GOODCRC));
+
+	memcpy(chip->rec_load, buf, len);
+
+	return 0;
+}
+
+static void fusb302_flush_rx_fifo(struct fusb30x_chip *chip)
+{
+	regmap_write(chip->regmap, FUSB_REG_CONTROL1, CONTROL1_RX_FLUSH);
+}
+
+static int tcpm_get_cc(struct fusb30x_chip *chip, int *CC1, int *CC2)
+{
+	u32 val;
+	int *CC_MEASURE;
+	u32 store;
+
+	*CC1 = TYPEC_CC_VOLT_OPEN;
+	*CC2 = TYPEC_CC_VOLT_OPEN;
+
+	if (chip->cc_state & CC_STATE_TOGSS_CC1)
+		CC_MEASURE = CC1;
+	else
+		CC_MEASURE = CC2;
+
+	if (chip->cc_state & CC_STATE_TOGSS_IS_UFP) {
+		regmap_read(chip->regmap, FUSB_REG_SWITCHES0, &store);
+		/* measure cc1 first */
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+				   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2 |
+				   SWITCHES0_PU_EN1 | SWITCHES0_PU_EN2 |
+				   SWITCHES0_PDWN1 | SWITCHES0_PDWN2,
+				   SWITCHES0_PDWN1 | SWITCHES0_PDWN2 |
+				   SWITCHES0_MEAS_CC1);
+		usleep_range(250, 300);
+
+		regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+		val &= STATUS0_BC_LVL;
+		*CC1 = val ? TYPEC_CC_VOLT_RP : TYPEC_CC_VOLT_OPEN;
+
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+				   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2 |
+				   SWITCHES0_PU_EN1 | SWITCHES0_PU_EN2 |
+				   SWITCHES0_PDWN1 | SWITCHES0_PDWN2,
+				   SWITCHES0_PDWN1 | SWITCHES0_PDWN2 |
+				   SWITCHES0_MEAS_CC2);
+		usleep_range(250, 300);
+
+		regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+		val &= STATUS0_BC_LVL;
+		*CC2 = val ? TYPEC_CC_VOLT_RP : TYPEC_CC_VOLT_OPEN;
+
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+				   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2,
+				   store);
+	} else {
+		regmap_read(chip->regmap, FUSB_REG_SWITCHES0, &store);
+		val = store;
+		val &= ~(SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2 |
+				SWITCHES0_PU_EN1 | SWITCHES0_PU_EN2);
+		if (chip->cc_state & CC_STATE_TOGSS_CC1) {
+			val |= SWITCHES0_MEAS_CC1 | SWITCHES0_PU_EN1;
+		} else {
+			val |= SWITCHES0_MEAS_CC2 | SWITCHES0_PU_EN2;
+		}
+		regmap_write(chip->regmap, FUSB_REG_SWITCHES0, val);
+
+		regmap_write(chip->regmap, FUSB_REG_MEASURE, chip->cc_meas_high);
+		usleep_range(250, 300);
+
+		regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+		if (val & STATUS0_COMP) {
+			int retry = 3;
+			int comp_times = 0;
+
+			while (retry--) {
+				regmap_write(chip->regmap, FUSB_REG_MEASURE, chip->cc_meas_high);
+				usleep_range(250, 300);
+				regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+				if (val & STATUS0_COMP) {
+					comp_times++;
+					if (comp_times == 3) {
+						*CC_MEASURE = TYPEC_CC_VOLT_OPEN;
+						regmap_write(chip->regmap, FUSB_REG_SWITCHES0, store);
+					}
+				}
+			}
+		} else {
+			regmap_write(chip->regmap, FUSB_REG_MEASURE, chip->cc_meas_low);
+			regmap_read(chip->regmap, FUSB_REG_MEASURE, &val);
+			usleep_range(250, 300);
+
+			regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+
+			if (val & STATUS0_COMP)
+				*CC_MEASURE = TYPEC_CC_VOLT_RD;
+			else
+				*CC_MEASURE = TYPEC_CC_VOLT_RA;
+		}
+		regmap_write(chip->regmap, FUSB_REG_SWITCHES0, store);
+		regmap_write(chip->regmap, FUSB_REG_MEASURE,
+			     chip->cc_meas_high);
+	}
+
+	return 0;
+}
+
+static void tcpm_set_cc_pull_mode(struct fusb30x_chip *chip, enum CC_MODE mode)
+{
+	u8 val;
+
+	switch (mode) {
+	case CC_PULL_UP:
+		if (chip->cc_polarity == TYPEC_POLARITY_CC1)
+			val = SWITCHES0_PU_EN1;
+		else
+			val = SWITCHES0_PU_EN2;
+		break;
+	case CC_PULL_DOWN:
+		val = SWITCHES0_PDWN1 | SWITCHES0_PDWN2;
+		break;
+	default:
+		val = 0;
+		break;
+	}
+
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+			   SWITCHES0_PU_EN1 | SWITCHES0_PU_EN2 |
+			   SWITCHES0_PDWN1 | SWITCHES0_PDWN2,
+			   val);
+
+	if (chip->cc_meas_high && mode == CC_PULL_UP)
+		regmap_write(chip->regmap, FUSB_REG_MEASURE,
+			     chip->cc_meas_high);
+}
+
+static int tcpm_set_cc(struct fusb30x_chip *chip, enum role_mode mode)
+{
+	switch (mode) {
+	case ROLE_MODE_DFP:
+		tcpm_set_cc_pull_mode(chip, CC_PULL_UP);
+		regmap_update_bits(chip->regmap, FUSB_REG_CONTROL2,
+				   CONTROL2_MODE | CONTROL2_TOG_RD_ONLY,
+				   CONTROL2_MODE_DFP | CONTROL2_TOG_RD_ONLY);
+		break;
+	case ROLE_MODE_UFP:
+		tcpm_set_cc_pull_mode(chip, CC_PULL_UP);
+		regmap_update_bits(chip->regmap, FUSB_REG_CONTROL2,
+				   CONTROL2_MODE | CONTROL2_TOG_RD_ONLY,
+				   CONTROL2_MODE_UFP);
+		break;
+	case ROLE_MODE_DRP:
+		tcpm_set_cc_pull_mode(chip, CC_PULL_NONE);
+		regmap_update_bits(chip->regmap, FUSB_REG_CONTROL2,
+				   CONTROL2_MODE | CONTROL2_TOG_RD_ONLY,
+				   CONTROL2_MODE_DRP | CONTROL2_TOG_RD_ONLY);
+		break;
+	default:
+		dev_err(chip->dev, "%s: Unsupport cc mode %d\n",
+			__func__, mode);
+		return -EINVAL;
+		break;
+	}
+
+	regmap_update_bits(chip->regmap, FUSB_REG_CONTROL2, CONTROL2_TOGGLE,
+			   CONTROL2_TOGGLE);
+
+	return 0;
+}
+
+static int tcpm_set_rx_enable(struct fusb30x_chip *chip, int enable)
+{
+	u8 val = 0;
+
+	if (enable) {
+		if (chip->cc_polarity == TYPEC_POLARITY_CC1)
+			val |= SWITCHES0_MEAS_CC1;
+		else
+			val |= SWITCHES0_MEAS_CC2;
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+				   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2,
+				   val);
+		fusb302_flush_rx_fifo(chip);
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES1,
+				   SWITCHES1_AUTO_CRC, SWITCHES1_AUTO_CRC);
+	} else {
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+				   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2,
+				   0);
+		regmap_update_bits(chip->regmap,
+				   FUSB_REG_SWITCHES1, SWITCHES1_AUTO_CRC, 0);
+	}
+
+	return 0;
+}
+
+static int tcpm_set_msg_header(struct fusb30x_chip *chip)
+{
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES1,
+			   SWITCHES1_POWERROLE | SWITCHES1_DATAROLE,
+			   (chip->notify.power_role << 7) |
+			   (chip->notify.data_role << 4));
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES1,
+			   SWITCHES1_SPECREV, 2 << 5);
+	return 0;
+}
+
+static int tcpm_set_polarity(struct fusb30x_chip *chip,
+			     enum typec_cc_polarity polarity)
+{
+	u8 val = 0;
+
+	if (chip->vconn_enabled) {
+		if (polarity)
+			val |= SWITCHES0_VCONN_CC1;
+		else
+			val |= SWITCHES0_VCONN_CC2;
+	}
+
+	if (chip->cc_state & CC_STATE_TOGSS_IS_UFP) {
+		if (polarity == TYPEC_POLARITY_CC1)
+			val |= SWITCHES0_MEAS_CC1;
+		else
+			val |= SWITCHES0_MEAS_CC2;
+	} else {
+		if (polarity == TYPEC_POLARITY_CC1)
+			val |= SWITCHES0_MEAS_CC1 | SWITCHES0_PU_EN1;
+		else
+			val |= SWITCHES0_MEAS_CC2 | SWITCHES0_PU_EN2;
+	}
+
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+			   SWITCHES0_VCONN_CC1 | SWITCHES0_VCONN_CC2 |
+			   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2 |
+			   SWITCHES0_PU_EN1 | SWITCHES0_PU_EN2,
+			   val);
+
+	val = 0;
+	if (polarity == TYPEC_POLARITY_CC1)
+		val |= SWITCHES1_TXCC1;
+	else
+		val |= SWITCHES1_TXCC2;
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES1,
+			   SWITCHES1_TXCC1 | SWITCHES1_TXCC2,
+			   val);
+
+	chip->cc_polarity = polarity;
+
+	return 0;
+}
+
+static int tcpm_set_vconn(struct fusb30x_chip *chip, int enable)
+{
+	u8 val = 0;
+
+	if (enable) {
+		if (chip->cc_polarity == TYPEC_POLARITY_CC1)
+			val = SWITCHES0_VCONN_CC2;
+		else
+			val = SWITCHES0_VCONN_CC1;
+	}
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+			   SWITCHES0_VCONN_CC1 | SWITCHES0_VCONN_CC2,
+			   val);
+	chip->vconn_enabled = (bool)enable;
+	return 0;
+}
+
+static void fusb302_pd_reset(struct fusb30x_chip *chip)
+{
+	regmap_write(chip->regmap, FUSB_REG_RESET, RESET_PD_RESET);
+	regmap_reinit_cache(chip->regmap, &fusb302_regmap_config);
+}
+
+static void tcpm_select_rp_value(struct fusb30x_chip *chip, u32 rp)
+{
+	u32 control0_reg;
+
+	regmap_read(chip->regmap, FUSB_REG_CONTROL0, &control0_reg);
+
+	control0_reg &= ~CONTROL0_HOST_CUR;
+	/*
+	 * according to the host current, the compare value is different
+	 * Fusb302 datasheet Table 3
+	 */
+	switch (rp) {
+	/*
+	 * host pull up current is 80ua , high voltage is 1.596v,
+	 * low is 0.21v
+	 */
+	case TYPEC_RP_USB:
+		chip->cc_meas_high = 0x26;
+		chip->cc_meas_low = 0x5;
+		control0_reg |= CONTROL0_HOST_CUR_USB;
+		break;
+	/*
+	 * host pull up current is 330ua , high voltage is 2.604v,
+	 * low is 0.798v
+	 */
+	case TYPEC_RP_3A0:
+		chip->cc_meas_high = 0x3e;
+		chip->cc_meas_low = 0x13;
+		control0_reg |= CONTROL0_HOST_CUR_3A0;
+		break;
+	/*
+	 * host pull up current is 180ua , high voltage is 1.596v,
+	 * low is 0.42v
+	 */
+	case TYPEC_RP_1A5:
+	default:
+		chip->cc_meas_high = 0x26;
+		chip->cc_meas_low = 0xa;
+		control0_reg |= CONTROL0_HOST_CUR_1A5;
+		break;
+	}
+
+	regmap_write(chip->regmap, FUSB_REG_CONTROL0, control0_reg);
+}
+
+static int tcpm_check_vbus(struct fusb30x_chip *chip)
+{
+	u32 val;
+
+	/* Read status register */
+	regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+
+	return (val & STATUS0_VBUSOK) ? 1 : 0;
+}
+
+static void tcpm_init(struct fusb30x_chip *chip)
+{
+	u8 val;
+	u32 tmp;
+
+	regmap_read(chip->regmap, FUSB_REG_DEVICEID, &tmp);
+	chip->chip_id = (u8)tmp;
+	platform_set_vbus_lvl_enable(chip, 0, 0);
+	chip->notify.is_cc_connected = false;
+	chip->cc_state = 0;
+
+	/* restore default settings */
+	regmap_update_bits(chip->regmap, FUSB_REG_RESET, RESET_SW_RESET,
+			   RESET_SW_RESET);
+	fusb302_pd_reset(chip);
+	/* set auto_retry and number of retries */
+	regmap_update_bits(chip->regmap, FUSB_REG_CONTROL3,
+			   CONTROL3_AUTO_RETRY | CONTROL3_N_RETRIES,
+			   CONTROL3_AUTO_RETRY | CONTROL3_N_RETRIES),
+
+	/* set interrupts */
+	val = 0xff;
+	val &= ~(MASK_M_COLLISION | MASK_M_ALERT | MASK_M_VBUSOK);
+	regmap_write(chip->regmap, FUSB_REG_MASK, val);
+
+	val = 0xff;
+	val &= ~(MASKA_M_RETRYFAIL | MASKA_M_HARDSENT | MASKA_M_TXSENT |
+		 MASKA_M_HARDRST | MASKA_M_TOGDONE);
+	regmap_write(chip->regmap, FUSB_REG_MASKA, val);
+
+	val = ~MASKB_M_GCRCSEND;
+	regmap_write(chip->regmap, FUSB_REG_MASKB, val);
+
+	tcpm_select_rp_value(chip, TYPEC_RP_1A5);
+	/* Interrupts Enable */
+	regmap_update_bits(chip->regmap, FUSB_REG_CONTROL0, CONTROL0_INT_MASK,
+			   ~CONTROL0_INT_MASK);
+
+	tcpm_set_vconn(chip, 0);
+
+	regmap_write(chip->regmap, FUSB_REG_POWER, 0xf);
+}
+
+static void pd_execute_hard_reset(struct fusb30x_chip *chip)
+{
+	chip->msg_id = 0;
+	chip->vdm_state = VDM_STATE_DISCOVERY_ID;
+	if (chip->notify.power_role)
+		set_state(chip, policy_src_transition_default);
+	else
+		set_state(chip, policy_snk_transition_default);
+}
+
+static void tcpc_alert(struct fusb30x_chip *chip, u32 *evt)
+{
+	int interrupt, interrupta, interruptb;
+	u32 val;
+	static int retry;
+
+	regmap_read(chip->regmap, FUSB_REG_INTERRUPT, &interrupt);
+	regmap_read(chip->regmap, FUSB_REG_INTERRUPTA, &interrupta);
+	regmap_read(chip->regmap, FUSB_REG_INTERRUPTB, &interruptb);
+
+	if ((interrupt & INTERRUPT_COMP_CHNG) &&
+	    (!(chip->cc_state & CC_STATE_TOGSS_IS_UFP))) {
+		regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+		if (val & STATUS0_COMP)
+			*evt |= EVENT_CC;
+	}
+
+	if (interrupt & INTERRUPT_VBUSOK) {
+		if (chip->notify.is_cc_connected)
+			*evt |= EVENT_CC;
+	}
+
+	if (interrupta & INTERRUPTA_TOGDONE) {
+		*evt |= EVENT_CC;
+		regmap_read(chip->regmap, FUSB_REG_STATUS1A, &val);
+		chip->cc_state = ((u8)val >> 3) & 0x07;
+
+		regmap_update_bits(chip->regmap, FUSB_REG_CONTROL2,
+				   CONTROL2_TOGGLE,
+				   0);
+	}
+
+	if (interrupta & INTERRUPTA_TXSENT) {
+		*evt |= EVENT_TX;
+		chip->tx_state = tx_success;
+	}
+
+	if (interruptb & INTERRUPTB_GCRCSENT)
+		*evt |= EVENT_RX;
+
+	if (interrupta & INTERRUPTA_HARDRST) {
+		fusb302_pd_reset(chip);
+		pd_execute_hard_reset(chip);
+		*evt |= EVENT_REC_RESET;
+	}
+
+	if (interrupta & INTERRUPTA_RETRYFAIL) {
+		*evt |= EVENT_TX;
+		chip->tx_state = tx_failed;
+	}
+
+	if (interrupta & INTERRUPTA_HARDSENT) {
+		/*
+		 * The fusb PD should be reset once to sync adapter PD
+		 * signal after fusb sent hard reset cmd.This is not PD
+		 * device if reset failed.
+		 */
+		if (!retry) {
+			retry = 1;
+			fusb302_pd_reset(chip);
+			pd_execute_hard_reset(chip);
+		} else {
+			retry = 0;
+			chip->tx_state = tx_success;
+			chip->timer_state = T_DISABLED;
+			*evt |= EVENT_TX;
+		}
+	}
+}
+
+static void mux_alert(struct fusb30x_chip *chip, u32 *evt)
+{
+	if (!chip->timer_mux) {
+		*evt |= EVENT_TIMER_MUX;
+		chip->timer_mux = T_DISABLED;
+	}
+
+	if (!chip->timer_state) {
+		*evt |= EVENT_TIMER_STATE;
+		chip->timer_state = T_DISABLED;
+	}
+
+	if (chip->work_continue) {
+		*evt |= chip->work_continue;
+		chip->work_continue = 0;
+	}
+}
+
+static void set_state_unattached(struct fusb30x_chip *chip)
+{
+	dev_info(chip->dev, "connection has disconnected\n");
+	tcpm_init(chip);
+	tcpm_set_rx_enable(chip, 0);
+	set_state(chip, unattached);
+	tcpm_set_cc(chip, chip->role);
+
+	/* claer notify_info */
+	memset(&chip->notify, 0, sizeof(struct notify_info));
+	platform_fusb_notify(chip);
+
+	if (chip->gpio_discharge)
+		gpiod_set_value(chip->gpio_discharge, 1);
+	msleep(100);
+	if (chip->gpio_discharge)
+		gpiod_set_value(chip->gpio_discharge, 0);
+
+	regmap_update_bits(chip->regmap, FUSB_REG_MASK,
+			   MASK_M_COMP_CHNG, MASK_M_COMP_CHNG);
+	chip->try_role_complete = false;
+}
+
+static void set_mesg(struct fusb30x_chip *chip, int cmd, int is_DMT)
+{
+	int i;
+	struct PD_CAP_INFO *pd_cap_info = &chip->pd_cap_info;
+
+	chip->send_head = ((chip->msg_id & 0x7) << 9) |
+			 ((chip->notify.power_role & 0x1) << 8) |
+			 (1 << 6) |
+			 ((chip->notify.data_role & 0x1) << 5);
+
+	if (is_DMT) {
+		switch (cmd) {
+		case DMT_SOURCECAPABILITIES:
+			chip->send_head |= ((chip->n_caps_used & 0x3) << 12) | (cmd & 0xf);
+
+			for (i = 0; i < chip->n_caps_used; i++) {
+				chip->send_load[i] = (pd_cap_info->supply_type << 30) |
+						    (pd_cap_info->dual_role_power << 29) |
+						    (pd_cap_info->usb_suspend_support << 28) |
+						    (pd_cap_info->externally_powered << 27) |
+						    (pd_cap_info->usb_communications_cap << 26) |
+						    (pd_cap_info->data_role_swap << 25) |
+						    (pd_cap_info->peak_current << 20) |
+						    (chip->source_power_supply[i] << 10) |
+						    (chip->source_max_current[i]);
+			}
+			break;
+		case DMT_REQUEST:
+			chip->send_head |= ((1 << 12) | (cmd & 0xf));
+			/* send request with FVRDO */
+			chip->send_load[0] = (chip->pos_power << 28) |
+					    (0 << 27) |
+					    (1 << 26) |
+					    (0 << 25) |
+					    (0 << 24);
+
+			switch (CAP_POWER_TYPE(chip->rec_load[chip->pos_power - 1])) {
+			case 0:
+				/* Fixed Supply */
+				chip->send_load[0] |= ((CAP_FPDO_VOLTAGE(chip->rec_load[chip->pos_power - 1]) << 10) & 0x3ff);
+				chip->send_load[0] |= (CAP_FPDO_CURRENT(chip->rec_load[chip->pos_power - 1]) & 0x3ff);
+				break;
+			case 1:
+				/* Battery */
+				chip->send_load[0] |= ((CAP_VPDO_VOLTAGE(chip->rec_load[chip->pos_power - 1]) << 10) & 0x3ff);
+				chip->send_load[0] |= (CAP_VPDO_CURRENT(chip->rec_load[chip->pos_power - 1]) & 0x3ff);
+				break;
+			default:
+				/* not meet battery caps */
+				break;
+			}
+			break;
+		case DMT_SINKCAPABILITIES:
+			break;
+		case DMT_VENDERDEFINED:
+			break;
+		default:
+			break;
+		}
+	} else {
+		chip->send_head |= (cmd & 0xf);
+	}
+}
+
+/*
+ * This algorithm defaults to choosing higher pin config over lower ones in
+ * order to prefer multi-function if desired.
+ *
+ *  NAME | SIGNALING | OUTPUT TYPE | MULTI-FUNCTION | PIN CONFIG
+ * -------------------------------------------------------------
+ *  A    |  USB G2   |  ?          | no             | 00_0001
+ *  B    |  USB G2   |  ?          | yes            | 00_0010
+ *  C    |  DP       |  CONVERTED  | no             | 00_0100
+ *  D    |  PD       |  CONVERTED  | yes            | 00_1000
+ *  E    |  DP       |  DP         | no             | 01_0000
+ *  F    |  PD       |  DP         | yes            | 10_0000
+ *
+ * if UFP has NOT asserted multi-function preferred code masks away B/D/F
+ * leaving only A/C/E.  For single-output dongles that should leave only one
+ * possible pin config depending on whether its a converter DP->(VGA|HDMI) or DP
+ * output.  If UFP is a USB-C receptacle it may assert C/D/E/F.  The DFP USB-C
+ * receptacle must always choose C/D in those cases.
+ */
+static int pd_dfp_dp_get_pin_assignment(struct fusb30x_chip *chip,
+					uint32_t caps, uint32_t status)
+{
+	uint32_t pin_caps;
+
+	/* revisit with DFP that can be a sink */
+	pin_caps = PD_DP_PIN_CAPS(caps);
+
+	/* if don't want multi-function then ignore those pin configs */
+	if (!PD_VDO_DPSTS_MF_PREF(status))
+		pin_caps &= ~MODE_DP_PIN_MF_MASK;
+
+	/* revisit if DFP drives USB Gen 2 signals */
+	if (PD_DP_SIGNAL_GEN2(caps))
+		pin_caps &= ~MODE_DP_PIN_DP_MASK;
+	else
+		pin_caps &= ~MODE_DP_PIN_BR2_MASK;
+
+	/* if C/D present they have precedence over E/F for USB-C->USB-C */
+	if (pin_caps & (MODE_DP_PIN_C | MODE_DP_PIN_D))
+		pin_caps &= ~(MODE_DP_PIN_E | MODE_DP_PIN_F);
+
+	/* returns undefined for zero */
+	if (!pin_caps)
+		return 0;
+
+	/* choosing higher pin config over lower ones */
+	return 1 << (31 - __builtin_clz(pin_caps));
+}
+
+static void set_vdm_mesg(struct fusb30x_chip *chip, int cmd, int type, int mode)
+{
+	chip->send_head = (chip->msg_id & 0x7) << 9;
+	chip->send_head |= (chip->notify.power_role & 0x1) << 8;
+
+	chip->send_head = ((chip->msg_id & 0x7) << 9) |
+			 ((chip->notify.power_role & 0x1) << 8) |
+			 (1 << 6) |
+			 ((chip->notify.data_role & 0x1) << 5) |
+			 (DMT_VENDERDEFINED & 0xf);
+
+	chip->send_load[0] = (1 << 15) |
+			    (0 << 13) |
+			    (type << 6) |
+			    (cmd);
+
+	switch (cmd) {
+	case VDM_DISCOVERY_ID:
+	case VDM_DISCOVERY_SVIDS:
+	case VDM_ATTENTION:
+		chip->send_load[0] |= (0xff00 << 16);
+		chip->send_head |= (1 << 12);
+		break;
+	case VDM_DISCOVERY_MODES:
+		chip->send_load[0] |=
+			(chip->vdm_svid[chip->val_tmp >> 1] << 16);
+		chip->send_head |= (1 << 12);
+		break;
+	case VDM_ENTER_MODE:
+		chip->send_head |= (1 << 12);
+		chip->send_load[0] |= (mode << 8) | (0xff01 << 16);
+		break;
+	case VDM_EXIT_MODE:
+		chip->send_head |= (1 << 12);
+		chip->send_load[0] |= (0x0f << 8) | (0xff01 << 16);
+		break;
+	case VDM_DP_STATUS_UPDATE:
+		chip->send_head |= (2 << 12);
+		chip->send_load[0] |= (1 << 8) | (0xff01 << 16);
+		chip->send_load[1] = 5;
+		break;
+	case VDM_DP_CONFIG:
+		chip->send_head |= (2 << 12);
+		chip->send_load[0] |= (1 << 8) | (0xff01 << 16);
+
+		chip->notify.pin_assignment_def =
+			pd_dfp_dp_get_pin_assignment(chip, chip->notify.dp_caps,
+						     chip->notify.dp_status);
+
+		chip->send_load[1] = (chip->notify.pin_assignment_def << 8) |
+				    (1 << 2) | 2;
+		dev_dbg(chip->dev, "DisplayPort Configurations: 0x%08x\n",
+			chip->send_load[1]);
+		break;
+	default:
+		break;
+	}
+}
+
+static enum tx_state policy_send_hardrst(struct fusb30x_chip *chip, u32 evt)
+{
+	switch (chip->tx_state) {
+	case 0:
+		regmap_update_bits(chip->regmap, FUSB_REG_CONTROL3,
+				   CONTROL3_SEND_HARDRESET,
+				   CONTROL3_SEND_HARDRESET);
+		chip->tx_state = tx_busy;
+		chip->timer_state = T_BMC_TIMEOUT;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		break;
+	default:
+		if (evt & EVENT_TIMER_STATE)
+			chip->tx_state = tx_success;
+		break;
+	}
+	return chip->tx_state;
+}
+
+static enum tx_state policy_send_data(struct fusb30x_chip *chip)
+{
+	u8 senddata[40];
+	int pos = 0;
+	u8 len;
+
+	switch (chip->tx_state) {
+	case 0:
+		senddata[pos++] = FUSB_TKN_SYNC1;
+		senddata[pos++] = FUSB_TKN_SYNC1;
+		senddata[pos++] = FUSB_TKN_SYNC1;
+		senddata[pos++] = FUSB_TKN_SYNC2;
+
+		len = PD_HEADER_CNT(chip->send_head) << 2;
+		senddata[pos++] = FUSB_TKN_PACKSYM | ((len + 2) & 0x1f);
+
+		senddata[pos++] = chip->send_head & 0xff;
+		senddata[pos++] = (chip->send_head >> 8) & 0xff;
+
+		memcpy(&senddata[pos], chip->send_load, len);
+		pos += len;
+
+		senddata[pos++] = FUSB_TKN_JAMCRC;
+		senddata[pos++] = FUSB_TKN_EOP;
+		senddata[pos++] = FUSB_TKN_TXOFF;
+		senddata[pos++] = FUSB_TKN_TXON;
+
+		regmap_raw_write(chip->regmap, FUSB_REG_FIFO, senddata, pos);
+		chip->tx_state = tx_busy;
+		break;
+
+	default:
+		/* wait Tx result */
+		break;
+	}
+
+	return chip->tx_state;
+}
+
+static void process_vdm_msg(struct fusb30x_chip *chip)
+{
+	u32 vdm_header = chip->rec_load[0];
+	int i;
+	u32 tmp;
+
+	/* can't procee unstructed vdm msg */
+	if (!GET_VDMHEAD_STRUCT_TYPE(vdm_header)) {
+		dev_warn(chip->dev, "unknown unstructed vdm message\n");
+		return;
+	}
+
+	switch (GET_VDMHEAD_CMD_TYPE(vdm_header)) {
+	case VDM_TYPE_INIT:
+		switch (GET_VDMHEAD_CMD(vdm_header)) {
+		case VDM_ATTENTION:
+			chip->notify.dp_status = GET_DP_STATUS(chip->rec_load[1]);
+			dev_info(chip->dev, "attention, dp_status %x\n",
+				 chip->rec_load[1]);
+			chip->notify.attention = true;
+			platform_fusb_notify(chip);
+			break;
+		default:
+			dev_warn(chip->dev, "rec unknown init vdm msg\n");
+			break;
+		}
+		break;
+	case VDM_TYPE_ACK:
+		switch (GET_VDMHEAD_CMD(vdm_header)) {
+		case VDM_DISCOVERY_ID:
+			chip->vdm_id = chip->rec_load[1];
+			break;
+		case VDM_DISCOVERY_SVIDS:
+			for (i = 0; i < 6; i++) {
+				tmp = (chip->rec_load[i + 1] >> 16) &
+				      0x0000ffff;
+				if (tmp) {
+					chip->vdm_svid[i * 2] = tmp;
+					chip->vdm_svid_num++;
+				} else {
+					break;
+				}
+
+				tmp = (chip->rec_load[i + 1] & 0x0000ffff);
+				if (tmp) {
+					chip->vdm_svid[i * 2 + 1] = tmp;
+					chip->vdm_svid_num++;
+				} else {
+					break;
+				}
+			}
+			break;
+		case VDM_DISCOVERY_MODES:
+			/* indicate there are some vdo modes */
+			if (PD_HEADER_CNT(chip->rec_head) > 1) {
+				/*
+				 * store mode config,
+				 * enter first mode default
+				 */
+				tmp = chip->rec_load[1];
+
+				if ((!((tmp >> 8) & 0x3f)) &&
+				    (!((tmp >> 16) & 0x3f))) {
+					chip->val_tmp |= 1;
+					break;
+				}
+				chip->notify.dp_caps = chip->rec_load[1];
+				chip->notify.pin_assignment_def = 0;
+				chip->notify.pin_assignment_support =
+							PD_DP_PIN_CAPS(tmp);
+				chip->val_tmp |= 1;
+				dev_dbg(chip->dev,
+					"DisplayPort Capabilities: 0x%08x\n",
+					chip->rec_load[1]);
+			}
+			break;
+		case VDM_ENTER_MODE:
+			chip->val_tmp = 1;
+			break;
+		case VDM_DP_STATUS_UPDATE:
+			chip->notify.dp_status = GET_DP_STATUS(chip->rec_load[1]);
+			dev_dbg(chip->dev, "DisplayPort Status: 0x%08x\n",
+				chip->rec_load[1]);
+			chip->val_tmp = 1;
+			break;
+		case VDM_DP_CONFIG:
+			chip->val_tmp = 1;
+			dev_info(chip->dev,
+				 "DP config successful, pin_assignment 0x%x\n",
+				 chip->notify.pin_assignment_def);
+			chip->notify.is_enter_mode = true;
+			break;
+		default:
+			break;
+		}
+		break;
+	case VDM_TYPE_NACK:
+			dev_warn(chip->dev, "REC NACK for 0x%x\n",
+				 GET_VDMHEAD_CMD(vdm_header));
+			/* disable vdm */
+			chip->vdm_state = VDM_STATE_ERR;
+		break;
+	}
+}
+
+static int vdm_send_discoveryid(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	switch (chip->vdm_send_state) {
+	case 0:
+		set_vdm_mesg(chip, VDM_DISCOVERY_ID, VDM_TYPE_INIT, 0);
+		chip->vdm_id = 0;
+		chip->tx_state = 0;
+		chip->vdm_send_state++;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->vdm_send_state++;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			dev_warn(chip->dev, "VDM_DISCOVERY_ID send failed\n");
+			/* disable auto_vdm_machine */
+			chip->vdm_state = VDM_STATE_ERR;
+			return -EPIPE;
+		}
+
+		if (chip->vdm_send_state != 2)
+			break;
+	default:
+		if (chip->vdm_id) {
+			chip->vdm_send_state = 0;
+			return 0;
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "VDM_DISCOVERY_ID time out\n");
+			chip->vdm_state = VDM_STATE_ERR;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			return -ETIMEDOUT;
+		}
+		break;
+	}
+	return -EINPROGRESS;
+}
+
+static int vdm_send_discoverysvid(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	switch (chip->vdm_send_state) {
+	case 0:
+		set_vdm_mesg(chip, VDM_DISCOVERY_SVIDS, VDM_TYPE_INIT, 0);
+		memset(chip->vdm_svid, 0, sizeof(chip->vdm_svid));
+		chip->vdm_svid_num = 0;
+		chip->tx_state = 0;
+		chip->vdm_send_state++;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->vdm_send_state++;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			dev_warn(chip->dev, "VDM_DISCOVERY_SVIDS send failed\n");
+			/* disable auto_vdm_machine */
+			chip->vdm_state = VDM_STATE_ERR;
+			return -EPIPE;
+		}
+
+		if (chip->vdm_send_state != 2)
+			break;
+	default:
+		if (chip->vdm_svid_num) {
+			chip->vdm_send_state = 0;
+			return 0;
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "VDM_DISCOVERY_SVIDS time out\n");
+			chip->vdm_state = VDM_STATE_ERR;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			return -ETIMEDOUT;
+		}
+		break;
+	}
+	return -EINPROGRESS;
+}
+
+static int vdm_send_discoverymodes(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	if ((chip->val_tmp >> 1) != chip->vdm_svid_num) {
+		switch (chip->vdm_send_state) {
+		case 0:
+			set_vdm_mesg(chip, VDM_DISCOVERY_MODES,
+				     VDM_TYPE_INIT, 0);
+			chip->tx_state = 0;
+			chip->vdm_send_state++;
+		case 1:
+			tmp = policy_send_data(chip);
+			if (tmp == tx_success) {
+				chip->vdm_send_state++;
+				chip->timer_state = T_SENDER_RESPONSE;
+				fusb_timer_start(&chip->timer_state_machine,
+						 chip->timer_state);
+			} else if (tmp == tx_failed) {
+				dev_warn(chip->dev,
+					 "VDM_DISCOVERY_MODES send failed\n");
+				chip->vdm_state = VDM_STATE_ERR;
+				return -EPIPE;
+			}
+
+			if (chip->vdm_send_state != 2)
+				break;
+		default:
+			if (chip->val_tmp & 1) {
+				chip->val_tmp &= 0xfe;
+				chip->val_tmp += 2;
+				chip->vdm_send_state = 0;
+				chip->work_continue |= EVENT_WORK_CONTINUE;
+			} else if (evt & EVENT_TIMER_STATE) {
+				dev_warn(chip->dev,
+					 "VDM_DISCOVERY_MODES time out\n");
+				chip->vdm_state = VDM_STATE_ERR;
+				chip->work_continue |= EVENT_WORK_CONTINUE;
+				return -ETIMEDOUT;
+			}
+			break;
+		}
+	} else {
+		chip->val_tmp = 0;
+		return 0;
+	}
+
+	return -EINPROGRESS;
+}
+
+static int vdm_send_entermode(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	switch (chip->vdm_send_state) {
+	case 0:
+		set_vdm_mesg(chip, VDM_ENTER_MODE, VDM_TYPE_INIT, 1);
+		chip->tx_state = 0;
+		chip->vdm_send_state++;
+		chip->notify.is_enter_mode = false;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->vdm_send_state++;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			dev_warn(chip->dev, "VDM_ENTER_MODE send failed\n");
+			/* disable auto_vdm_machine */
+			chip->vdm_state = VDM_STATE_ERR;
+			return -EPIPE;
+		}
+
+		if (chip->vdm_send_state != 2)
+			break;
+	default:
+		if (chip->val_tmp) {
+			chip->val_tmp = 0;
+			chip->vdm_send_state = 0;
+			return 0;
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "VDM_ENTER_MODE time out\n");
+			chip->vdm_state = VDM_STATE_ERR;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			return -ETIMEDOUT;
+		}
+		break;
+	}
+	return -EINPROGRESS;
+}
+
+static int vdm_send_getdpstatus(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	switch (chip->vdm_send_state) {
+	case 0:
+		set_vdm_mesg(chip, VDM_DP_STATUS_UPDATE, VDM_TYPE_INIT, 1);
+		chip->tx_state = 0;
+		chip->vdm_send_state++;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->vdm_send_state++;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			dev_warn(chip->dev,
+				 "VDM_DP_STATUS_UPDATE send failed\n");
+			/* disable auto_vdm_machine */
+			chip->vdm_state = VDM_STATE_ERR;
+			return -EPIPE;
+		}
+
+		if (chip->vdm_send_state != 2)
+			break;
+	default:
+		if (chip->val_tmp) {
+			chip->val_tmp = 0;
+			chip->vdm_send_state = 0;
+			return 0;
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "VDM_DP_STATUS_UPDATE time out\n");
+			chip->vdm_state = VDM_STATE_ERR;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			return -ETIMEDOUT;
+		}
+		break;
+	}
+	return -EINPROGRESS;
+}
+
+static int vdm_send_dpconfig(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	switch (chip->vdm_send_state) {
+	case 0:
+		set_vdm_mesg(chip, VDM_DP_CONFIG, VDM_TYPE_INIT, 0);
+		chip->tx_state = 0;
+		chip->vdm_send_state++;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->vdm_send_state++;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			dev_warn(chip->dev, "vdm_send_dpconfig send failed\n");
+			/* disable auto_vdm_machine */
+			chip->vdm_state = VDM_STATE_ERR;
+			return -EPIPE;
+		}
+
+		if (chip->vdm_send_state != 2)
+			break;
+	default:
+		if (chip->val_tmp) {
+			chip->val_tmp = 0;
+			chip->vdm_send_state = 0;
+			return 0;
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "vdm_send_dpconfig time out\n");
+			chip->vdm_state = VDM_STATE_ERR;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			return -ETIMEDOUT;
+		}
+		break;
+	}
+	return -EINPROGRESS;
+}
+
+/* without break if success */
+#define AUTO_VDM_HANDLE(func, chip, evt, conditions) \
+do { \
+	conditions = func(chip, evt); \
+	if (!conditions) { \
+		chip->vdm_state++; \
+		chip->work_continue |= EVENT_WORK_CONTINUE; \
+	} else { \
+		if (conditions != -EINPROGRESS) \
+			chip->vdm_state = VDM_STATE_ERR; \
+	} \
+} while (0)
+
+static void auto_vdm_machine(struct fusb30x_chip *chip, u32 evt)
+{
+	int conditions;
+
+	switch (chip->vdm_state) {
+	case VDM_STATE_DISCOVERY_ID:
+		AUTO_VDM_HANDLE(vdm_send_discoveryid, chip, evt, conditions);
+		break;
+	case VDM_STATE_DISCOVERY_SVID:
+		AUTO_VDM_HANDLE(vdm_send_discoverysvid, chip, evt, conditions);
+		break;
+	case VDM_STATE_DISCOVERY_MODES:
+		AUTO_VDM_HANDLE(vdm_send_discoverymodes, chip, evt, conditions);
+		break;
+	case VDM_STATE_ENTER_MODE:
+		AUTO_VDM_HANDLE(vdm_send_entermode, chip, evt, conditions);
+		break;
+	case VDM_STATE_UPDATE_STATUS:
+		AUTO_VDM_HANDLE(vdm_send_getdpstatus, chip, evt, conditions);
+		break;
+	case VDM_STATE_DP_CONFIG:
+		AUTO_VDM_HANDLE(vdm_send_dpconfig, chip, evt, conditions);
+		break;
+	case VDM_STATE_NOTIFY:
+		platform_fusb_notify(chip);
+		chip->vdm_state = VDM_STATE_READY;
+		break;
+	default:
+		break;
+	}
+}
+
+static void fusb_state_disabled(struct fusb30x_chip *chip, u32 evt)
+{
+	/* Do nothing */
+}
+
+static void fusb_state_unattached(struct fusb30x_chip *chip, u32 evt)
+{
+	chip->notify.is_cc_connected = false;
+	chip->is_pd_support = false;
+
+	if ((evt & EVENT_CC) && chip->cc_state) {
+		if (chip->cc_state & CC_STATE_TOGSS_IS_UFP)
+			set_state(chip, attach_wait_sink);
+		else
+			set_state(chip, attach_wait_source);
+
+		chip->vbus_begin = tcpm_check_vbus(chip);
+
+		tcpm_set_polarity(chip, (chip->cc_state & CC_STATE_TOGSS_CC1) ?
+					TYPEC_POLARITY_CC1 :
+					TYPEC_POLARITY_CC2);
+		tcpm_get_cc(chip, &chip->cc1, &chip->cc2);
+		chip->debounce_cnt = 0;
+		chip->timer_mux = 2;
+		fusb_timer_start(&chip->timer_mux_machine, chip->timer_mux);
+	}
+}
+
+static void fusb_state_try_attach_set(struct fusb30x_chip *chip,
+				      enum role_mode mode)
+{
+	if (mode == ROLE_MODE_NONE || mode == ROLE_MODE_DRP ||
+	    mode == ROLE_MODE_ASS)
+		return;
+
+	tcpm_init(chip);
+	tcpm_set_cc(chip, (mode == ROLE_MODE_DFP) ?
+			  ROLE_MODE_DFP : ROLE_MODE_UFP);
+	chip->timer_mux = T_PD_TRY_DRP;
+	fusb_timer_start(&chip->timer_mux_machine, chip->timer_mux);
+	set_state(chip, (mode == ROLE_MODE_DFP) ?
+			attach_try_src : attach_try_snk);
+}
+
+static void fusb_state_attach_wait_sink(struct fusb30x_chip *chip, u32 evt)
+{
+	int cc1, cc2;
+
+	if (evt & EVENT_TIMER_MUX) {
+		if (tcpm_check_vbus(chip)) {
+			chip->timer_mux = T_DISABLED;
+			if (chip->role == ROLE_MODE_DRP &&
+			    chip->try_role == ROLE_MODE_DFP &&
+			    !chip->try_role_complete) {
+				fusb_state_try_attach_set(chip, ROLE_MODE_DFP);
+				return;
+			} else if (chip->try_role_complete) {
+				chip->timer_mux = T_PD_SOURCE_ON;
+				fusb_timer_start(&chip->timer_mux_machine,
+						 chip->timer_mux);
+				set_state(chip, attached_sink);
+				return;
+			}
+		}
+
+		tcpm_get_cc(chip, &cc1, &cc2);
+
+		if ((chip->cc1 == cc1) && (chip->cc2 == cc2)) {
+			chip->debounce_cnt++;
+		} else {
+			chip->cc1 = cc1;
+			chip->cc2 = cc2;
+			chip->debounce_cnt = 0;
+		}
+
+		if (chip->debounce_cnt > N_DEBOUNCE_CNT) {
+			chip->timer_mux = T_DISABLED;
+			if ((chip->cc1 == TYPEC_CC_VOLT_RP &&
+			     chip->cc2 == TYPEC_CC_VOLT_OPEN) ||
+			    (chip->cc2 == TYPEC_CC_VOLT_RP &&
+			     chip->cc1 == TYPEC_CC_VOLT_OPEN)) {
+				chip->timer_mux = T_PD_SOURCE_ON;
+				fusb_timer_start(&chip->timer_mux_machine,
+						 chip->timer_mux);
+				set_state(chip, attached_sink);
+			} else {
+				set_state_unattached(chip);
+			}
+			return;
+		}
+
+		chip->timer_mux = 2;
+		fusb_timer_start(&chip->timer_mux_machine,
+				 chip->timer_mux);
+	}
+}
+
+static void fusb_state_attach_wait_source(struct fusb30x_chip *chip, u32 evt)
+{
+	int cc1, cc2;
+
+	if (evt & EVENT_TIMER_MUX) {
+		tcpm_get_cc(chip, &cc1, &cc2);
+
+		if ((chip->cc1 == cc1) && (chip->cc2 == cc2)) {
+			chip->debounce_cnt++;
+		} else {
+			chip->cc1 = cc1;
+			chip->cc2 = cc2;
+			chip->debounce_cnt = 0;
+		}
+
+		if (chip->debounce_cnt > N_DEBOUNCE_CNT) {
+			if (((!chip->cc1) || (!chip->cc2)) &&
+			    ((chip->cc1 == TYPEC_CC_VOLT_RD) ||
+			     (chip->cc2 == TYPEC_CC_VOLT_RD))) {
+				if (chip->role == ROLE_MODE_DRP &&
+				    chip->try_role == ROLE_MODE_UFP &&
+				    !chip->try_role_complete)
+					fusb_state_try_attach_set(chip,
+							ROLE_MODE_UFP);
+				else
+					set_state(chip, attached_source);
+			} else {
+				set_state_unattached(chip);
+			}
+			return;
+		}
+
+		chip->timer_mux = 2;
+		fusb_timer_start(&chip->timer_mux_machine,
+				 chip->timer_mux);
+	}
+}
+
+static void fusb_state_attached_source(struct fusb30x_chip *chip, u32 evt)
+{
+	platform_set_vbus_lvl_enable(chip, 1, 0);
+	tcpm_set_polarity(chip, (chip->cc_state & CC_STATE_TOGSS_CC1) ?
+				TYPEC_POLARITY_CC1 : TYPEC_POLARITY_CC2);
+	tcpm_set_vconn(chip, 1);
+
+	chip->notify.is_cc_connected = true;
+
+	chip->notify.power_role = POWER_ROLE_SOURCE;
+	chip->notify.data_role = DATA_ROLE_DFP;
+	chip->hardrst_count = 0;
+	set_state(chip, policy_src_startup);
+	regmap_update_bits(chip->regmap, FUSB_REG_MASK, MASK_M_COMP_CHNG, 0);
+	dev_info(chip->dev, "CC connected in %s as DFP\n",
+		 chip->cc_polarity ? "CC1" : "CC2");
+}
+
+static void fusb_state_attached_sink(struct fusb30x_chip *chip, u32 evt)
+{
+	if (tcpm_check_vbus(chip)) {
+		chip->timer_mux = T_DISABLED;
+		chip->timer_state = T_DISABLED;
+		if (!chip->try_role_complete &&
+		    chip->try_role == ROLE_MODE_DFP &&
+		    chip->role == ROLE_MODE_DRP) {
+			fusb_state_try_attach_set(chip, ROLE_MODE_DFP);
+			return;
+		}
+
+		chip->try_role_complete = true;
+		chip->notify.is_cc_connected = true;
+		chip->notify.power_role = POWER_ROLE_SINK;
+		chip->notify.data_role = DATA_ROLE_UFP;
+		chip->hardrst_count = 0;
+		set_state(chip, policy_snk_startup);
+		dev_info(chip->dev, "CC connected in %s as UFP\n",
+			 chip->cc_polarity ? "CC1" : "CC2");
+		return;
+	} else if (evt & EVENT_TIMER_MUX) {
+		set_state_unattached(chip);
+		return;
+	}
+
+	chip->timer_state = 2;
+	fusb_timer_start(&chip->timer_state_machine,
+			 chip->timer_state);
+}
+
+static void fusb_state_try_attach(struct fusb30x_chip *chip, u32 evt,
+				  enum role_mode mode)
+{
+	if ((evt & EVENT_CC) && chip->cc_state) {
+		chip->try_role_complete = true;
+		if (chip->cc_state & CC_STATE_TOGSS_IS_UFP)
+			set_state(chip, (mode == ROLE_MODE_UFP) ?
+					attach_wait_sink : error_recovery);
+		else
+			set_state(chip, (mode == ROLE_MODE_DFP) ?
+					attach_wait_source : error_recovery);
+
+		tcpm_set_polarity(chip, (chip->cc_state & CC_STATE_TOGSS_CC1) ?
+					TYPEC_POLARITY_CC1 :
+					TYPEC_POLARITY_CC2);
+		tcpm_get_cc(chip, &chip->cc1, &chip->cc2);
+		chip->debounce_cnt = 0;
+		chip->timer_mux = 2;
+		fusb_timer_start(&chip->timer_mux_machine, chip->timer_mux);
+	} else if (evt & EVENT_TIMER_MUX) {
+		if (!chip->try_role_complete) {
+			chip->try_role_complete = true;
+			fusb_state_try_attach_set(chip,
+						  (mode == ROLE_MODE_DFP) ?
+						  ROLE_MODE_UFP :
+						  ROLE_MODE_DFP);
+		} else {
+			set_state(chip, error_recovery);
+		}
+	}
+}
+
+static void fusb_soft_reset_parameter(struct fusb30x_chip *chip)
+{
+	chip->caps_counter = 0;
+	chip->msg_id = 0;
+	chip->vdm_state = VDM_STATE_DISCOVERY_ID;
+	chip->vdm_substate = 0;
+	chip->vdm_send_state = 0;
+	chip->val_tmp = 0;
+	chip->pos_power = 0;
+}
+
+static void fusb_state_src_startup(struct fusb30x_chip *chip, u32 evt)
+{
+	chip->notify.is_pd_connected = false;
+	fusb_soft_reset_parameter(chip);
+
+	memset(chip->partner_cap, 0, sizeof(chip->partner_cap));
+
+	tcpm_set_msg_header(chip);
+	tcpm_set_polarity(chip, chip->cc_polarity);
+	tcpm_set_rx_enable(chip, 1);
+
+	set_state(chip, policy_src_send_caps);
+	platform_fusb_notify(chip);
+}
+
+static void fusb_state_src_discovery(struct fusb30x_chip *chip, u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->caps_counter++;
+
+		if (chip->caps_counter < N_CAPS_COUNT) {
+			chip->timer_state = T_TYPEC_SEND_SOURCECAP;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->sub_state = 1;
+		} else {
+			set_state(chip, disabled);
+		}
+		break;
+	default:
+		if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_src_send_caps);
+		} else if (evt & EVENT_TIMER_MUX) {
+			if (!chip->is_pd_support)
+				set_state(chip, disabled);
+			else if (chip->hardrst_count > N_HARDRESET_COUNT)
+				set_state(chip, error_recovery);
+			else
+				set_state(chip, policy_src_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_send_caps(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, DMT_SOURCECAPABILITIES, DATAMESSAGE);
+		chip->sub_state = 1;
+		chip->tx_state = tx_idle;
+		/* without break */
+	case 1:
+		tmp = policy_send_data(chip);
+
+		if (tmp == tx_success) {
+			chip->hardrst_count = 0;
+			chip->caps_counter = 0;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->timer_mux = T_DISABLED;
+			chip->sub_state++;
+			chip->is_pd_support = true;
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_discovery);
+			break;
+		}
+
+		if (!(evt & FLAG_EVENT))
+			break;
+	default:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_DATA_MSG(chip->rec_head, DMT_REQUEST)) {
+				set_state(chip, policy_src_negotiate_cap);
+			} else {
+				set_state(chip, policy_src_send_softrst);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			if (chip->hardrst_count <= N_HARDRESET_COUNT)
+				set_state(chip, policy_src_send_hardrst);
+			else
+				set_state(chip, disabled);
+		} else if (evt & EVENT_TIMER_MUX) {
+			if (!chip->is_pd_support)
+				set_state(chip, disabled);
+			else if (chip->hardrst_count > N_HARDRESET_COUNT)
+				set_state(chip, error_recovery);
+			else
+				set_state(chip, policy_src_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_negotiate_cap(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	/* base on evb1 */
+	tmp = (chip->rec_load[0] >> 28) & 0x07;
+	if (tmp > chip->n_caps_used)
+		set_state(chip, policy_src_cap_response);
+	else
+		set_state(chip, policy_src_transition_supply);
+}
+
+static void fusb_state_src_transition_supply(struct fusb30x_chip *chip,
+					     u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_ACCEPT, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->timer_state = T_SRC_TRANSITION;
+			chip->sub_state++;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_softrst);
+		}
+		break;
+	case 2:
+		if (evt & EVENT_TIMER_STATE) {
+			chip->notify.is_pd_connected = true;
+			platform_set_vbus_lvl_enable(chip, 1, 0);
+			set_mesg(chip, CMT_PS_RDY, CONTROLMESSAGE);
+			chip->tx_state = tx_idle;
+			chip->sub_state++;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+		}
+		break;
+	default:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			dev_info(chip->dev,
+				 "PD connected as DFP, supporting 5V\n");
+			set_state(chip, policy_src_ready);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_softrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_cap_response(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_REJECT, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	default:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			if (chip->notify.is_pd_connected) {
+				dev_info(chip->dev,
+					 "PD connected as DFP, supporting 5V\n");
+				set_state(chip, policy_src_ready);
+			} else {
+				set_state(chip, policy_src_send_hardrst);
+			}
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_softrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_transition_default(struct fusb30x_chip *chip,
+					      u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->notify.is_pd_connected = false;
+		platform_set_vbus_lvl_enable(chip, 0, 0);
+		if (chip->notify.data_role)
+			regmap_update_bits(chip->regmap,
+					   FUSB_REG_SWITCHES1,
+					   SWITCHES1_DATAROLE,
+					   SWITCHES1_DATAROLE);
+		else
+			regmap_update_bits(chip->regmap,
+					   FUSB_REG_SWITCHES1,
+					   SWITCHES1_DATAROLE,
+					   0);
+
+		chip->timer_state = T_SRC_RECOVER;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		chip->sub_state++;
+		break;
+	default:
+		if (evt & EVENT_TIMER_STATE) {
+			platform_set_vbus_lvl_enable(chip, 1, 0);
+			chip->timer_mux = T_NO_RESPONSE;
+			fusb_timer_start(&chip->timer_mux_machine,
+					 chip->timer_mux);
+			set_state(chip, policy_src_startup);
+			dev_dbg(chip->dev, "reset over-> src startup\n");
+		}
+		break;
+	}
+}
+
+static void fusb_state_vcs_ufp_evaluate_swap(struct fusb30x_chip *chip, u32 evt)
+{
+	if (chip->vconn_supported)
+		set_state(chip, policy_vcs_ufp_accept);
+	else
+		set_state(chip, policy_vcs_ufp_reject);
+}
+
+static void fusb_state_swap_msg_process(struct fusb30x_chip *chip, u32 evt)
+{
+	if (evt & EVENT_RX) {
+		if (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_PR_SWAP)) {
+			set_state(chip, policy_src_prs_evaluate);
+		} else if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+						 CMT_VCONN_SWAP)) {
+			if (chip->notify.data_role)
+				set_state(chip, chip->conn_state);
+			else
+				set_state(chip, policy_vcs_ufp_evaluate_swap);
+		} else if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+						 CMT_DR_SWAP)) {
+			if (chip->notify.data_role)
+				set_state(chip, policy_drs_dfp_evaluate);
+			else
+				set_state(chip, policy_drs_ufp_evaluate);
+		}
+	}
+}
+
+#define VDM_IS_ACTIVE(chip) \
+	(chip->notify.data_role && chip->vdm_state < VDM_STATE_READY)
+
+static void fusb_state_src_ready(struct fusb30x_chip *chip, u32 evt)
+{
+	if (evt & EVENT_RX) {
+		if (PACKET_IS_DATA_MSG(chip->rec_head, DMT_VENDERDEFINED)) {
+			process_vdm_msg(chip);
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			chip->timer_state = T_DISABLED;
+		} else if (!VDM_IS_ACTIVE(chip)) {
+			fusb_state_swap_msg_process(chip, evt);
+		}
+	}
+
+	if (!chip->partner_cap[0])
+		set_state(chip, policy_src_get_sink_caps);
+	else if (VDM_IS_ACTIVE(chip))
+		auto_vdm_machine(chip, evt);
+}
+
+static void fusb_state_prs_evaluate(struct fusb30x_chip *chip, u32 evt)
+{
+	if (chip->role == ROLE_MODE_DRP)
+		set_state(chip, policy_src_prs_accept);
+	else
+		set_state(chip, policy_src_prs_reject);
+}
+
+static void fusb_state_send_simple_msg(struct fusb30x_chip *chip, u32 evt,
+				       int cmd, int is_DMT,
+				       enum connection_state state_success,
+				       enum connection_state state_failed)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, cmd, is_DMT);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* fallthrough */
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success)
+			set_state(chip, state_success);
+		else if (tmp == tx_failed)
+			set_state(chip, state_failed);
+	}
+}
+
+static void fusb_state_prs_reject(struct fusb30x_chip *chip, u32 evt)
+{
+	fusb_state_send_simple_msg(chip, evt, CMT_REJECT, CONTROLMESSAGE,
+				   (chip->notify.power_role) ?
+				   policy_src_ready : policy_snk_ready,
+				   (chip->notify.power_role) ?
+				   policy_src_send_softrst :
+				   policy_snk_send_softrst);
+}
+
+static void fusb_state_prs_accept(struct fusb30x_chip *chip, u32 evt)
+{
+	fusb_state_send_simple_msg(chip, evt, CMT_ACCEPT, CONTROLMESSAGE,
+				   (chip->notify.power_role) ?
+				   policy_src_prs_transition_to_off :
+				   policy_snk_prs_transition_to_off,
+				   (chip->notify.power_role) ?
+				   policy_src_send_softrst :
+				   policy_snk_send_softrst);
+}
+
+static void fusb_state_vcs_ufp_accept(struct fusb30x_chip *chip, u32 evt)
+{
+	fusb_state_send_simple_msg(chip, evt, CMT_ACCEPT, CONTROLMESSAGE,
+				   (chip->vconn_enabled) ?
+				   policy_vcs_ufp_wait_for_dfp_vconn :
+				   policy_vcs_ufp_turn_on_vconn,
+				   (chip->notify.power_role) ?
+				   policy_src_send_softrst :
+				   policy_snk_send_softrst);
+}
+
+static void fusb_state_vcs_set_vconn(struct fusb30x_chip *chip,
+				     u32 evt, bool on)
+{
+	if (on) {
+		tcpm_set_vconn(chip, 1);
+		set_state(chip, chip->notify.data_role ?
+				policy_vcs_dfp_send_ps_rdy :
+				policy_vcs_ufp_send_ps_rdy);
+	} else {
+		tcpm_set_vconn(chip, 0);
+		if (chip->notify.power_role)
+			set_state(chip, policy_src_ready);
+		else
+			set_state(chip, policy_snk_ready);
+	}
+}
+
+static void fusb_state_vcs_send_ps_rdy(struct fusb30x_chip *chip, u32 evt)
+{
+	fusb_state_send_simple_msg(chip, evt, CMT_PS_RDY, CONTROLMESSAGE,
+				   (chip->notify.power_role) ?
+				   policy_src_ready : policy_snk_ready,
+				   (chip->notify.power_role) ?
+				   policy_src_send_softrst :
+				   policy_snk_send_softrst);
+}
+
+static void fusb_state_vcs_wait_for_vconn(struct fusb30x_chip *chip,
+					  u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->timer_state = T_PD_VCONN_SRC_ON;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		chip->sub_state++;
+		/* fallthrough */
+	case 1:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_PS_RDY))
+				set_state(chip, chip->notify.data_role ?
+						policy_vcs_dfp_turn_off_vconn :
+						policy_vcs_ufp_turn_off_vconn);
+		} else if (evt & EVENT_TIMER_STATE) {
+			if (chip->notify.power_role)
+				set_state(chip, policy_src_send_hardrst);
+			else
+				set_state(chip, policy_snk_send_hardrst);
+		}
+	}
+}
+
+static void fusb_state_src_prs_transition_to_off(struct fusb30x_chip *chip,
+						 u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->timer_state = T_SRC_TRANSITION;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		chip->sub_state++;
+		break;
+	case 1:
+		if (evt & EVENT_TIMER_STATE) {
+			platform_set_vbus_lvl_enable(chip, 0, 0);
+			chip->notify.power_role = POWER_ROLE_SINK;
+			tcpm_set_msg_header(chip);
+			if (chip->role == ROLE_MODE_DRP)
+				set_state(chip, policy_src_prs_assert_rd);
+			else
+				set_state(chip, policy_src_prs_source_off);
+		}
+	}
+}
+
+static void fusb_state_src_prs_assert_rd(struct fusb30x_chip *chip, u32 evt)
+{
+	tcpm_set_cc_pull_mode(chip, CC_PULL_DOWN);
+	set_state(chip, policy_src_prs_source_off);
+}
+
+static void fusb_state_src_prs_source_off(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_PS_RDY, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* fallthrough */
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->timer_state = T_PD_SOURCE_ON;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->sub_state++;
+		} else if (tmp == tx_failed) {
+			chip->notify.power_role = POWER_ROLE_SOURCE;
+			tcpm_set_msg_header(chip);
+			set_state(chip, policy_src_send_hardrst);
+		}
+		if (chip->sub_state != 3)
+			break;
+	case 2:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+						  CMT_PS_RDY)) {
+				chip->timer_state = T_DISABLED;
+				/* snk startup */
+				chip->notify.is_pd_connected = false;
+				chip->cc_state |= CC_STATE_TOGSS_IS_UFP;
+				tcpm_set_polarity(chip, chip->cc_polarity);
+				tcpm_set_rx_enable(chip, 1);
+				set_state(chip, policy_snk_discovery);
+			} else {
+				dev_dbg(chip->dev,
+					"rec careless msg: head %x\n",
+					chip->rec_head);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			chip->notify.power_role = POWER_ROLE_SOURCE;
+			tcpm_set_msg_header(chip);
+			set_state(chip, policy_src_send_hardrst);
+		}
+	}
+}
+
+static void fusb_state_drs_evaluate(struct fusb30x_chip *chip, u32 evt)
+{
+	if (chip->pd_cap_info.data_role_swap)
+		/*
+		 * TODO:
+		 * NOW REJECT swap when the port is DFP
+		 * since we should work together with USB part
+		 */
+		set_state(chip, chip->notify.data_role ?
+				policy_drs_dfp_reject : policy_drs_ufp_accept);
+	else
+		set_state(chip, chip->notify.data_role ?
+				policy_drs_dfp_reject : policy_drs_ufp_reject);
+}
+
+static void fusb_state_drs_send_accept(struct fusb30x_chip *chip, u32 evt)
+{
+	fusb_state_send_simple_msg(chip, evt, CMT_ACCEPT, CONTROLMESSAGE,
+				   chip->notify.power_role ?
+				   policy_drs_dfp_change :
+				   policy_drs_ufp_change,
+				   error_recovery);
+}
+
+static void fusb_state_drs_role_change(struct fusb30x_chip *chip, u32 evt)
+{
+	chip->notify.data_role = chip->notify.data_role ?
+				 DATA_ROLE_UFP : DATA_ROLE_DFP;
+	tcpm_set_msg_header(chip);
+	set_state(chip, chip->notify.power_role ? policy_src_ready :
+						  policy_snk_ready);
+}
+
+static void fusb_state_src_get_sink_cap(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_GETSINKCAP, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->timer_state = T_SENDER_RESPONSE;
+			chip->sub_state++;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_softrst);
+		}
+
+		if (!(evt & FLAG_EVENT))
+			break;
+	default:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_DATA_MSG(chip->rec_head,
+					       DMT_SINKCAPABILITIES)) {
+				for (tmp = 0;
+				     tmp < PD_HEADER_CNT(chip->rec_head);
+				     tmp++) {
+					chip->partner_cap[tmp] =
+						chip->rec_load[tmp];
+				}
+				set_state(chip, policy_src_ready);
+			} else {
+				chip->partner_cap[0] = 0xffffffff;
+				set_state(chip, policy_src_ready);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "Get sink cap time out\n");
+			chip->partner_cap[0] = 0xffffffff;
+			set_state(chip, policy_src_ready);
+		}
+	}
+}
+
+static void fusb_state_src_send_hardreset(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	default:
+		tmp = policy_send_hardrst(chip, evt);
+		if (tmp == tx_success) {
+			chip->hardrst_count++;
+			set_state(chip, policy_src_transition_default);
+		} else if (tmp == tx_failed) {
+			/* can't reach here */
+			set_state(chip, error_recovery);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_softreset(struct fusb30x_chip *chip)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_ACCEPT, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	default:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			fusb_soft_reset_parameter(chip);
+			set_state(chip, policy_src_send_caps);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_send_softreset(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_SOFTRESET, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->timer_state = T_SENDER_RESPONSE;
+			chip->sub_state++;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_hardrst);
+		}
+
+		if (!(evt & FLAG_EVENT))
+			break;
+	default:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_ACCEPT)) {
+				fusb_soft_reset_parameter(chip);
+				set_state(chip, policy_src_send_caps);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_src_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_snk_startup(struct fusb30x_chip *chip, u32 evt)
+{
+	chip->notify.is_pd_connected = false;
+	fusb_soft_reset_parameter(chip);
+
+	memset(chip->partner_cap, 0, sizeof(chip->partner_cap));
+
+	tcpm_set_msg_header(chip);
+	tcpm_set_polarity(chip, chip->cc_polarity);
+	tcpm_set_rx_enable(chip, 1);
+	set_state(chip, policy_snk_discovery);
+	platform_fusb_notify(chip);
+}
+
+static void fusb_state_snk_discovery(struct fusb30x_chip *chip, u32 evt)
+{
+	set_state(chip, policy_snk_wait_caps);
+	chip->timer_state = T_TYPEC_SINK_WAIT_CAP;
+	fusb_timer_start(&chip->timer_state_machine,
+			 chip->timer_state);
+}
+
+static void fusb_state_snk_wait_caps(struct fusb30x_chip *chip, u32 evt)
+{
+	if (evt & EVENT_RX) {
+		if (PACKET_IS_DATA_MSG(chip->rec_head,
+				       DMT_SOURCECAPABILITIES)) {
+			chip->is_pd_support = true;
+			chip->timer_mux = T_DISABLED;
+			set_state(chip, policy_snk_evaluate_caps);
+		}
+	} else if (evt & EVENT_TIMER_STATE) {
+		if (chip->hardrst_count <= N_HARDRESET_COUNT) {
+			if (chip->vbus_begin) {
+				chip->vbus_begin = false;
+				set_state(chip, policy_snk_send_softrst);
+			} else {
+				set_state(chip, policy_snk_send_hardrst);
+			}
+		} else {
+			if (chip->is_pd_support)
+				set_state(chip, error_recovery);
+			else
+				set_state(chip, disabled);
+		}
+	} else if ((evt & EVENT_TIMER_MUX) &&
+		   (chip->hardrst_count > N_HARDRESET_COUNT)) {
+		if (chip->is_pd_support)
+			set_state(chip, error_recovery);
+		else
+			set_state(chip, disabled);
+	}
+}
+
+static void fusb_state_snk_evaluate_caps(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	chip->hardrst_count = 0;
+	chip->pos_power = 0;
+
+	for (tmp = 0; tmp < PD_HEADER_CNT(chip->rec_head); tmp++) {
+		switch (CAP_POWER_TYPE(chip->rec_load[tmp])) {
+		case 0:
+			/* Fixed Supply */
+			if (CAP_FPDO_VOLTAGE(chip->rec_load[tmp]) <= 100)
+				chip->pos_power = tmp + 1;
+			break;
+		case 1:
+			/* Battery */
+			if (CAP_VPDO_VOLTAGE(chip->rec_load[tmp]) <= 100)
+				chip->pos_power = tmp + 1;
+			break;
+		default:
+			/* not meet battery caps */
+			break;
+		}
+	}
+	fusb302_set_pos_power_by_charge_ic(chip);
+
+	if ((!chip->pos_power) || (chip->pos_power > 7)) {
+		chip->pos_power = 0;
+		set_state(chip, policy_snk_wait_caps);
+	} else {
+		set_state(chip, policy_snk_select_cap);
+	}
+}
+
+static void fusb_state_snk_select_cap(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, DMT_REQUEST, DATAMESSAGE);
+		chip->sub_state = 1;
+		chip->tx_state = tx_idle;
+		/* without break */
+	case 1:
+		tmp = policy_send_data(chip);
+
+		if (tmp == tx_success) {
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->sub_state++;
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_snk_discovery);
+			break;
+		}
+
+		if (!(evt & FLAG_EVENT))
+			break;
+	default:
+		if (evt & EVENT_RX) {
+			if (!PD_HEADER_CNT(chip->rec_head)) {
+				switch (PD_HEADER_TYPE(chip->rec_head)) {
+				case CMT_ACCEPT:
+					set_state(chip,
+						  policy_snk_transition_sink);
+					chip->timer_state = T_PS_TRANSITION;
+					fusb_timer_start(&chip->timer_state_machine,
+							 chip->timer_state);
+					break;
+				case CMT_WAIT:
+				case CMT_REJECT:
+					if (chip->notify.is_pd_connected) {
+						dev_info(chip->dev,
+							 "PD connected as UFP, fetching 5V\n");
+						set_state(chip,
+							  policy_snk_ready);
+					} else {
+						set_state(chip,
+							  policy_snk_wait_caps);
+						/*
+						 * make sure don't send
+						 * hard reset to prevent
+						 * infinite loop
+						 */
+						chip->hardrst_count =
+							N_HARDRESET_COUNT + 1;
+					}
+					break;
+				default:
+					break;
+				}
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_snk_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_snk_transition_sink(struct fusb30x_chip *chip, u32 evt)
+{
+	if (evt & EVENT_RX) {
+		if (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_PS_RDY)) {
+			chip->notify.is_pd_connected = true;
+			dev_info(chip->dev,
+				 "PD connected as UFP, fetching 5V\n");
+			set_state(chip, policy_snk_ready);
+		} else if (PACKET_IS_DATA_MSG(chip->rec_head,
+					      DMT_SOURCECAPABILITIES)) {
+			set_state(chip, policy_snk_evaluate_caps);
+		}
+	} else if (evt & EVENT_TIMER_STATE) {
+		set_state(chip, policy_snk_send_hardrst);
+	}
+}
+
+static void fusb_state_snk_transition_default(struct fusb30x_chip *chip,
+					      u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->notify.is_pd_connected = false;
+		chip->timer_mux = T_NO_RESPONSE;
+		fusb_timer_start(&chip->timer_mux_machine,
+				 chip->timer_mux);
+		chip->timer_state = T_PS_HARD_RESET_MAX + T_SAFE_0V;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		if (chip->notify.data_role)
+			tcpm_set_msg_header(chip);
+
+		chip->sub_state++;
+		/* fallthrough */
+	case 1:
+		if (!tcpm_check_vbus(chip)) {
+			chip->sub_state++;
+			chip->timer_state = T_SRC_RECOVER_MAX + T_SRC_TURN_ON;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_snk_startup);
+		}
+		break;
+	default:
+		if (tcpm_check_vbus(chip)) {
+			chip->timer_state = T_DISABLED;
+			set_state(chip, policy_snk_startup);
+		} else if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_snk_startup);
+		}
+		break;
+	}
+}
+
+static void fusb_state_snk_ready(struct fusb30x_chip *chip, u32 evt)
+{
+	if (evt & EVENT_RX) {
+		if (PACKET_IS_DATA_MSG(chip->rec_head, DMT_VENDERDEFINED)) {
+			process_vdm_msg(chip);
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			chip->timer_state = T_DISABLED;
+		} else if (!VDM_IS_ACTIVE(chip)) {
+			fusb_state_swap_msg_process(chip, evt);
+		}
+	}
+
+	if (VDM_IS_ACTIVE(chip))
+		auto_vdm_machine(chip, evt);
+
+	fusb_state_swap_msg_process(chip, evt);
+	platform_fusb_notify(chip);
+}
+
+static void fusb_state_snk_send_hardreset(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+	default:
+		tmp = policy_send_hardrst(chip, evt);
+		if (tmp == tx_success) {
+			chip->hardrst_count++;
+			set_state(chip, policy_snk_transition_default);
+		} else if (tmp == tx_failed) {
+			set_state(chip, error_recovery);
+		}
+		break;
+	}
+}
+
+static void fusb_state_send_swap(struct fusb30x_chip *chip, u32 evt, int cmd)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, cmd, CONTROLMESSAGE);
+		chip->sub_state = 1;
+		chip->tx_state = tx_idle;
+		/* fallthrough */
+	case 1:
+		tmp = policy_send_data(chip);
+
+		if (tmp == tx_success) {
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->sub_state++;
+		} else if (tmp == tx_failed) {
+			if (cmd == CMT_DR_SWAP) {
+				set_state(chip, error_recovery);
+				return;
+			}
+
+			if (chip->notify.power_role)
+				set_state(chip, policy_src_send_softrst);
+			else
+				set_state(chip, policy_snk_send_softrst);
+		}
+		break;
+	case 2:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+						  CMT_ACCEPT)) {
+				chip->timer_state = T_DISABLED;
+				if (cmd == CMT_VCONN_SWAP) {
+					set_state(chip, chip->vconn_enabled ?
+							policy_vcs_dfp_wait_for_ufp_vconn :
+							policy_vcs_dfp_turn_on_vconn);
+				} else if (cmd == CMT_PR_SWAP) {
+					if (chip->notify.power_role)
+						set_state(chip, policy_src_prs_transition_to_off);
+					else
+						set_state(chip, policy_snk_prs_transition_to_off);
+					chip->notify.power_role = POWER_ROLE_SOURCE;
+					tcpm_set_msg_header(chip);
+				} else if (cmd == CMT_DR_SWAP) {
+					set_state(chip, chip->notify.data_role ?
+							policy_drs_dfp_change :
+							policy_drs_ufp_change);
+				}
+			} else if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+							 CMT_REJECT) ||
+				   PACKET_IS_CONTROL_MSG(chip->rec_head,
+							 CMT_WAIT)) {
+				chip->timer_state = T_DISABLED;
+				if (chip->notify.power_role)
+					set_state(chip, policy_src_ready);
+				else
+					set_state(chip, policy_snk_ready);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			if (chip->notify.power_role)
+				set_state(chip, policy_src_ready);
+			else
+				set_state(chip, policy_snk_ready);
+		}
+	}
+}
+
+static void fusb_state_snk_prs_transition_to_off(struct fusb30x_chip *chip,
+						 u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->timer_state = T_PD_SOURCE_OFF;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		chip->sub_state++;
+		/* fallthrough */
+	case 1:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+						  CMT_PS_RDY)) {
+				if (chip->role == ROLE_MODE_DRP)
+					set_state(chip,
+						  policy_snk_prs_assert_rp);
+				else
+					set_state(chip,
+						  policy_snk_prs_source_on);
+			} else {
+				dev_dbg(chip->dev,
+					"rec careless msg: head %x\n",
+					chip->rec_head);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			chip->notify.power_role = POWER_ROLE_SINK;
+			tcpm_set_msg_header(chip);
+			set_state(chip, policy_snk_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_snk_prs_assert_rp(struct fusb30x_chip *chip, u32 evt)
+{
+	tcpm_set_cc_pull_mode(chip, CC_PULL_UP);
+	set_state(chip, policy_snk_prs_source_on);
+}
+
+static void fusb_state_snk_prs_source_on(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		/* supply power in 50ms */
+		platform_set_vbus_lvl_enable(chip, 1, 0);
+		chip->sub_state++;
+		chip->work_continue |= EVENT_WORK_CONTINUE;
+		break;
+	case 1:
+		set_mesg(chip, CMT_PS_RDY, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* fallthrough */
+	case 2:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			/* PD spe 6.5.10.2 */
+			chip->timer_state = T_PD_SWAP_SOURCE_START;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->sub_state++;
+		} else if (tmp == tx_failed) {
+			chip->notify.power_role = POWER_ROLE_SINK;
+			tcpm_set_msg_header(chip);
+			set_state(chip, policy_snk_send_hardrst);
+		}
+		break;
+	case 3:
+		if (evt & EVENT_TIMER_STATE) {
+			chip->cc_state &= ~CC_STATE_TOGSS_IS_UFP;
+			regmap_update_bits(chip->regmap, FUSB_REG_MASK,
+					   MASK_M_COMP_CHNG, 0);
+			set_state(chip, policy_src_send_caps);
+		}
+		break;
+	}
+}
+
+static void fusb_state_snk_softreset(struct fusb30x_chip *chip)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_ACCEPT, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	default:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			fusb_soft_reset_parameter(chip);
+			chip->timer_state = T_TYPEC_SINK_WAIT_CAP;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			set_state(chip, policy_snk_wait_caps);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_snk_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_snk_send_softreset(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_SOFTRESET, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->timer_state = T_SENDER_RESPONSE;
+			chip->sub_state++;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			/* can't reach here */
+			set_state(chip, policy_snk_send_hardrst);
+		}
+
+		if (!(evt & FLAG_EVENT))
+			break;
+	default:
+		if (evt & EVENT_RX) {
+			if ((!PD_HEADER_CNT(chip->rec_head)) &&
+			    (PD_HEADER_TYPE(chip->rec_head) == CMT_ACCEPT)) {
+				fusb_soft_reset_parameter(chip);
+				chip->timer_state = T_TYPEC_SINK_WAIT_CAP;
+				fusb_timer_start(&chip->timer_state_machine,
+						 chip->timer_state);
+				set_state(chip, policy_snk_wait_caps);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_snk_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_try_detach(struct fusb30x_chip *chip)
+{
+	int cc1, cc2;
+
+	if ((chip->cc_state & CC_STATE_TOGSS_IS_UFP) &&
+	    (chip->conn_state !=
+	     policy_snk_transition_default) &&
+	    (chip->conn_state !=
+	     policy_src_prs_source_off) &&
+	    (chip->conn_state != policy_snk_prs_send_swap) &&
+	    (chip->conn_state != policy_snk_prs_assert_rp) &&
+	    (chip->conn_state != policy_snk_prs_source_on) &&
+	    (chip->conn_state != policy_snk_prs_transition_to_off)) {
+		if (!tcpm_check_vbus(chip))
+			set_state_unattached(chip);
+	} else if ((chip->conn_state !=
+		    policy_src_transition_default) &&
+		   (chip->conn_state !=
+		    policy_src_prs_source_off) &&
+		   (chip->conn_state != policy_snk_prs_source_on)) {
+		tcpm_get_cc(chip, &cc1, &cc2);
+		if (chip->cc_state & CC_STATE_TOGSS_CC2)
+			cc1 = cc2;
+		if (cc1 == TYPEC_CC_VOLT_OPEN)
+			set_state_unattached(chip);
+	} else {
+		/*
+		 * Detached may occurred at swap operations. So, DON'T ignore
+		 * the EVENT_CC during swapping at all, check the connection
+		 * after it.
+		 */
+		chip->work_continue |= EVENT_DELAY_CC;
+	}
+}
+
+static void state_machine_typec(struct fusb30x_chip *chip)
+{
+	u32 evt = 0;
+
+	tcpc_alert(chip, &evt);
+	mux_alert(chip, &evt);
+	if (!evt)
+		goto BACK;
+
+	if (chip->notify.is_cc_connected)
+		if (evt & (EVENT_CC | EVENT_DELAY_CC))
+			fusb_try_detach(chip);
+
+	if (evt & EVENT_RX) {
+		tcpm_get_message(chip);
+		if (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_SOFTRESET)) {
+			if (chip->notify.power_role)
+				set_state(chip, policy_src_softrst);
+			else
+				set_state(chip, policy_snk_softrst);
+		}
+	}
+
+	if (evt & EVENT_TX) {
+		if (chip->tx_state == tx_success)
+			chip->msg_id++;
+	}
+	switch (chip->conn_state) {
+	case disabled:
+		fusb_state_disabled(chip, evt);
+		break;
+	case error_recovery:
+		set_state_unattached(chip);
+		break;
+	case unattached:
+		fusb_state_unattached(chip, evt);
+		break;
+	case attach_wait_sink:
+		fusb_state_attach_wait_sink(chip, evt);
+		break;
+	case attach_wait_source:
+		fusb_state_attach_wait_source(chip, evt);
+		break;
+	case attached_source:
+		fusb_state_attached_source(chip, evt);
+		break;
+	case attached_sink:
+		fusb_state_attached_sink(chip, evt);
+		break;
+	case attach_try_src:
+		fusb_state_try_attach(chip, evt, ROLE_MODE_DFP);
+		break;
+	case attach_try_snk:
+		fusb_state_try_attach(chip, evt, ROLE_MODE_UFP);
+		break;
+
+	/* POWER DELIVERY */
+	case policy_src_startup:
+		fusb_state_src_startup(chip, evt);
+		break;
+	case policy_src_discovery:
+		fusb_state_src_discovery(chip, evt);
+		break;
+	case policy_src_send_caps:
+		fusb_state_src_send_caps(chip, evt);
+		if (chip->conn_state != policy_src_negotiate_cap)
+			break;
+	case policy_src_negotiate_cap:
+		fusb_state_src_negotiate_cap(chip, evt);
+
+	case policy_src_transition_supply:
+		fusb_state_src_transition_supply(chip, evt);
+		break;
+	case policy_src_cap_response:
+		fusb_state_src_cap_response(chip, evt);
+		break;
+	case policy_src_transition_default:
+		fusb_state_src_transition_default(chip, evt);
+		break;
+	case policy_src_ready:
+		fusb_state_src_ready(chip, evt);
+		break;
+	case policy_src_get_sink_caps:
+		fusb_state_src_get_sink_cap(chip, evt);
+		break;
+	case policy_src_send_hardrst:
+		fusb_state_src_send_hardreset(chip, evt);
+		break;
+	case policy_src_send_softrst:
+		fusb_state_src_send_softreset(chip, evt);
+		break;
+	case policy_src_softrst:
+		fusb_state_src_softreset(chip);
+		break;
+
+	/* UFP */
+	case policy_snk_startup:
+		fusb_state_snk_startup(chip, evt);
+		break;
+	case policy_snk_discovery:
+		fusb_state_snk_discovery(chip, evt);
+		break;
+	case policy_snk_wait_caps:
+		fusb_state_snk_wait_caps(chip, evt);
+		break;
+	case policy_snk_evaluate_caps:
+		fusb_state_snk_evaluate_caps(chip, evt);
+		/* without break */
+	case policy_snk_select_cap:
+		fusb_state_snk_select_cap(chip, evt);
+		break;
+	case policy_snk_transition_sink:
+		fusb_state_snk_transition_sink(chip, evt);
+		break;
+	case policy_snk_transition_default:
+		fusb_state_snk_transition_default(chip, evt);
+		break;
+	case policy_snk_ready:
+		fusb_state_snk_ready(chip, evt);
+		break;
+	case policy_snk_send_hardrst:
+		fusb_state_snk_send_hardreset(chip, evt);
+		break;
+	case policy_snk_send_softrst:
+		fusb_state_snk_send_softreset(chip, evt);
+		break;
+	case policy_snk_softrst:
+		fusb_state_snk_softreset(chip);
+		break;
+
+	/*
+	 * PD Spec 1.0: PR SWAP: chap 8.3.3.6.3.1/2
+	 *		VC SWAP: chap 8.3.3.7.1/2
+	 */
+	case policy_src_prs_evaluate:
+	case policy_snk_prs_evaluate:
+		fusb_state_prs_evaluate(chip, evt);
+		break;
+	case policy_snk_prs_accept:
+	case policy_src_prs_accept:
+		fusb_state_prs_accept(chip, evt);
+		break;
+	case policy_snk_prs_reject:
+	case policy_src_prs_reject:
+	case policy_vcs_ufp_reject:
+	case policy_drs_dfp_reject:
+	case policy_drs_ufp_reject:
+		fusb_state_prs_reject(chip, evt);
+		break;
+	case policy_src_prs_transition_to_off:
+		fusb_state_src_prs_transition_to_off(chip, evt);
+		break;
+	case policy_src_prs_assert_rd:
+		fusb_state_src_prs_assert_rd(chip, evt);
+		break;
+	case policy_src_prs_source_off:
+		fusb_state_src_prs_source_off(chip, evt);
+		break;
+	case policy_snk_prs_send_swap:
+	case policy_src_prs_send_swap:
+		fusb_state_send_swap(chip, evt, CMT_PR_SWAP);
+		break;
+	case policy_snk_prs_transition_to_off:
+		fusb_state_snk_prs_transition_to_off(chip, evt);
+		break;
+	case policy_snk_prs_assert_rp:
+		fusb_state_snk_prs_assert_rp(chip, evt);
+		break;
+	case policy_snk_prs_source_on:
+		fusb_state_snk_prs_source_on(chip, evt);
+		break;
+	case policy_vcs_ufp_evaluate_swap:
+		fusb_state_vcs_ufp_evaluate_swap(chip, evt);
+		break;
+	case policy_vcs_ufp_accept:
+		fusb_state_vcs_ufp_accept(chip, evt);
+		break;
+	case policy_vcs_ufp_wait_for_dfp_vconn:
+	case policy_vcs_dfp_wait_for_ufp_vconn:
+		fusb_state_vcs_wait_for_vconn(chip, evt);
+		break;
+	case policy_vcs_ufp_turn_off_vconn:
+	case policy_vcs_dfp_turn_off_vconn:
+		fusb_state_vcs_set_vconn(chip, evt, false);
+		break;
+	case policy_vcs_ufp_turn_on_vconn:
+	case policy_vcs_dfp_turn_on_vconn:
+		fusb_state_vcs_set_vconn(chip, evt, true);
+		break;
+	case policy_vcs_ufp_send_ps_rdy:
+	case policy_vcs_dfp_send_ps_rdy:
+		fusb_state_vcs_send_ps_rdy(chip, evt);
+		break;
+	case policy_vcs_dfp_send_swap:
+		fusb_state_send_swap(chip, evt, CMT_VCONN_SWAP);
+		break;
+	case policy_drs_ufp_evaluate:
+	case policy_drs_dfp_evaluate:
+		fusb_state_drs_evaluate(chip, evt);
+		break;
+	case policy_drs_dfp_accept:
+	case policy_drs_ufp_accept:
+		fusb_state_drs_send_accept(chip, evt);
+		break;
+	case policy_drs_dfp_change:
+	case policy_drs_ufp_change:
+		fusb_state_drs_role_change(chip, evt);
+		break;
+	case policy_drs_ufp_send_swap:
+	case policy_drs_dfp_send_swap:
+		fusb_state_send_swap(chip, evt, CMT_DR_SWAP);
+		break;
+
+	default:
+		break;
+	}
+
+BACK:
+	if (chip->work_continue) {
+		queue_work(chip->fusb30x_wq, &chip->work);
+		return;
+	}
+
+	if (!platform_get_device_irq_state(chip))
+		fusb_irq_enable(chip);
+	else
+		queue_work(chip->fusb30x_wq, &chip->work);
+}
+
+static irqreturn_t cc_interrupt_handler(int irq, void *dev_id)
+{
+	struct fusb30x_chip *chip = dev_id;
+
+	queue_work(chip->fusb30x_wq, &chip->work);
+	fusb_irq_disable(chip);
+	return IRQ_HANDLED;
+}
+
+static int fusb_initialize_gpio(struct fusb30x_chip *chip)
+{
+	chip->gpio_int = devm_gpiod_get_optional(chip->dev, "int-n", GPIOD_IN);
+	if (IS_ERR(chip->gpio_int))
+		return PTR_ERR(chip->gpio_int);
+
+	/* some board support vbus with other ways */
+	chip->gpio_vbus_5v = devm_gpiod_get_optional(chip->dev, "vbus-5v",
+						     GPIOD_OUT_LOW);
+	if (IS_ERR(chip->gpio_vbus_5v))
+		dev_warn(chip->dev,
+			 "Could not get named GPIO for VBus5V!\n");
+	else
+		gpiod_set_raw_value(chip->gpio_vbus_5v, 0);
+
+	chip->gpio_vbus_other = devm_gpiod_get_optional(chip->dev,
+							"vbus-other",
+							GPIOD_OUT_LOW);
+	if (IS_ERR(chip->gpio_vbus_other))
+		dev_warn(chip->dev,
+			 "Could not get named GPIO for VBusOther!\n");
+	else
+		gpiod_set_raw_value(chip->gpio_vbus_other, 0);
+
+	chip->gpio_discharge = devm_gpiod_get_optional(chip->dev, "discharge",
+						       GPIOD_OUT_LOW);
+	if (IS_ERR(chip->gpio_discharge)) {
+		dev_warn(chip->dev,
+			 "Could not get named GPIO for discharge!\n");
+		chip->gpio_discharge = NULL;
+	}
+
+	return 0;
+}
+
+static enum hrtimer_restart fusb_timer_handler(struct hrtimer *timer)
+{
+	int i;
+
+	for (i = 0; i < fusb30x_port_used; i++) {
+		if (timer == &fusb30x_port_info[i]->timer_state_machine) {
+			if (fusb30x_port_info[i]->timer_state != T_DISABLED)
+				fusb30x_port_info[i]->timer_state = 0;
+			break;
+		}
+
+		if (timer == &fusb30x_port_info[i]->timer_mux_machine) {
+			if (fusb30x_port_info[i]->timer_mux != T_DISABLED)
+				fusb30x_port_info[i]->timer_mux = 0;
+			break;
+		}
+	}
+
+	if (i != fusb30x_port_used)
+		queue_work(fusb30x_port_info[i]->fusb30x_wq,
+			   &fusb30x_port_info[i]->work);
+
+	return HRTIMER_NORESTART;
+}
+
+static void fusb_initialize_timer(struct fusb30x_chip *chip)
+{
+	hrtimer_init(&chip->timer_state_machine, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	chip->timer_state_machine.function = fusb_timer_handler;
+
+	hrtimer_init(&chip->timer_mux_machine, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	chip->timer_mux_machine.function = fusb_timer_handler;
+
+	chip->timer_state = T_DISABLED;
+	chip->timer_mux = T_DISABLED;
+}
+
+static void fusb302_work_func(struct work_struct *work)
+{
+	struct fusb30x_chip *chip;
+
+	chip = container_of(work, struct fusb30x_chip, work);
+	state_machine_typec(chip);
+}
+
+static int fusb30x_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct fusb30x_chip *chip;
+	struct PD_CAP_INFO *pd_cap_info;
+	int ret;
+	char *string[2];
+
+	chip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	if (fusb30x_port_used == 0xff)
+		return -1;
+
+	chip->port_num = fusb30x_port_used++;
+	fusb30x_port_info[chip->port_num] = chip;
+
+	chip->dev = &client->dev;
+	chip->regmap = devm_regmap_init_i2c(client, &fusb302_regmap_config);
+	if (IS_ERR(chip->regmap)) {
+		dev_err(&client->dev, "Failed to allocate regmap!\n");
+		return PTR_ERR(chip->regmap);
+	}
+
+	ret = fusb_initialize_gpio(chip);
+	if (ret)
+		return ret;
+
+	fusb_initialize_timer(chip);
+
+	chip->fusb30x_wq = create_workqueue("fusb302_wq");
+	INIT_WORK(&chip->work, fusb302_work_func);
+
+	chip->role = ROLE_MODE_NONE;
+	chip->try_role = ROLE_MODE_NONE;
+	if (!of_property_read_string(chip->dev->of_node, "fusb302,role",
+				     (const char **)&string[0])) {
+		if (!strcmp(string[0], "ROLE_MODE_DRP"))
+			chip->role = ROLE_MODE_DRP;
+		else if (!strcmp(string[0], "ROLE_MODE_DFP"))
+			chip->role = ROLE_MODE_DFP;
+		else if (!strcmp(string[0], "ROLE_MODE_UFP"))
+			chip->role = ROLE_MODE_UFP;
+	}
+
+	if (chip->role == ROLE_MODE_NONE) {
+		dev_warn(chip->dev,
+			 "Can't get property of role, set role to default DRP\n");
+		chip->role = ROLE_MODE_DRP;
+		string[0] = "ROLE_MODE_DRP";
+	}
+
+	if (!of_property_read_string(chip->dev->of_node, "fusb302,try_role",
+				     (const char **)&string[1])) {
+		if (!strcmp(string[1], "ROLE_MODE_DFP"))
+			chip->try_role = ROLE_MODE_DFP;
+		else if (!strcmp(string[1], "ROLE_MODE_UFP"))
+			chip->try_role = ROLE_MODE_UFP;
+	}
+
+	if (chip->try_role == ROLE_MODE_NONE)
+		string[1] = "ROLE_MODE_NONE";
+
+	chip->vconn_supported = true;
+	tcpm_init(chip);
+	tcpm_set_rx_enable(chip, 0);
+	chip->conn_state = unattached;
+	tcpm_set_cc(chip, chip->role);
+
+	chip->n_caps_used = 1;
+	chip->source_power_supply[0] = 0x64;
+	chip->source_max_current[0] = 0x96;
+
+	pd_cap_info = &chip->pd_cap_info;
+	pd_cap_info->dual_role_power = 1;
+	pd_cap_info->data_role_swap = 1;
+
+	pd_cap_info->externally_powered = 1;
+	pd_cap_info->usb_suspend_support = 0;
+	pd_cap_info->usb_communications_cap = 0;
+	pd_cap_info->supply_type = 0;
+	pd_cap_info->peak_current = 0;
+
+	chip->extcon = devm_extcon_dev_allocate(&client->dev, fusb302_cable);
+	if (IS_ERR(chip->extcon)) {
+		dev_err(&client->dev, "allocat extcon failed\n");
+		return PTR_ERR(chip->extcon);
+	}
+
+	ret = devm_extcon_dev_register(&client->dev, chip->extcon);
+	if (ret) {
+		dev_err(&client->dev, "failed to register extcon: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(chip->extcon, EXTCON_USB,
+					     EXTCON_PROP_USB_TYPEC_POLARITY);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to set USB property capability: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(chip->extcon, EXTCON_USB_HOST,
+					     EXTCON_PROP_USB_TYPEC_POLARITY);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to set USB_HOST property capability: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(chip->extcon, EXTCON_DISP_DP,
+					     EXTCON_PROP_USB_TYPEC_POLARITY);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to set DISP_DP property capability: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(chip->extcon, EXTCON_USB,
+					     EXTCON_PROP_USB_SS);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to set USB USB_SS property capability: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(chip->extcon, EXTCON_USB_HOST,
+					     EXTCON_PROP_USB_SS);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to set USB_HOST USB_SS property capability: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(chip->extcon, EXTCON_DISP_DP,
+					     EXTCON_PROP_USB_SS);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to set DISP_DP USB_SS property capability: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(chip->extcon, EXTCON_CHG_USB_FAST,
+					     EXTCON_PROP_USB_TYPEC_POLARITY);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to set USB_PD property capability: %d\n", ret);
+		return ret;
+	}
+
+	i2c_set_clientdata(client, chip);
+
+	spin_lock_init(&chip->irq_lock);
+	chip->enable_irq = 1;
+
+	chip->gpio_int_irq = gpiod_to_irq(chip->gpio_int);
+	if (chip->gpio_int_irq < 0) {
+		dev_err(&client->dev,
+			"Unable to request IRQ for INT_N GPIO! %d\n",
+			ret);
+		ret = chip->gpio_int_irq;
+		goto IRQ_ERR;
+	}
+
+	ret = devm_request_threaded_irq(&client->dev,
+					chip->gpio_int_irq,
+					NULL,
+					cc_interrupt_handler,
+					IRQF_ONESHOT | IRQF_TRIGGER_LOW,
+					client->name,
+					chip);
+	if (ret) {
+		dev_err(&client->dev, "irq request failed\n");
+		goto IRQ_ERR;
+	}
+
+	dev_info(chip->dev,
+		 "port %d probe success with role %s, try_role %s\n",
+		 chip->port_num, string[0], string[1]);
+
+	return 0;
+
+IRQ_ERR:
+	destroy_workqueue(chip->fusb30x_wq);
+	return ret;
+}
+
+static int fusb30x_remove(struct i2c_client *client)
+{
+	struct fusb30x_chip *chip = i2c_get_clientdata(client);
+
+	destroy_workqueue(chip->fusb30x_wq);
+	return 0;
+}
+
+static void fusb30x_shutdown(struct i2c_client *client)
+{
+	struct fusb30x_chip *chip = i2c_get_clientdata(client);
+
+	if (chip->gpio_vbus_5v)
+		gpiod_set_value(chip->gpio_vbus_5v, 0);
+	if (chip->gpio_discharge) {
+		gpiod_set_value(chip->gpio_discharge, 1);
+		msleep(100);
+		gpiod_set_value(chip->gpio_discharge, 0);
+	}
+}
+
+static const struct of_device_id fusb30x_dt_match[] = {
+	{ .compatible = FUSB30X_I2C_DEVICETREE_NAME },
+	{},
+};
+MODULE_DEVICE_TABLE(of, fusb30x_dt_match);
+
+static const struct i2c_device_id fusb30x_i2c_device_id[] = {
+	{ FUSB30X_I2C_DRIVER_NAME, 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, fusb30x_i2c_device_id);
+
+static struct i2c_driver fusb30x_driver = {
+	.driver = {
+		.name = FUSB30X_I2C_DRIVER_NAME,
+		.of_match_table = of_match_ptr(fusb30x_dt_match),
+	},
+	.probe = fusb30x_probe,
+	.remove = fusb30x_remove,
+	.shutdown = fusb30x_shutdown,
+	.id_table = fusb30x_i2c_device_id,
+};
+
+module_i2c_driver(fusb30x_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("zain wang <zain.wang@rock-chips.com>");
+MODULE_DESCRIPTION("fusb302 typec pd driver");
diff --git a/drivers/staging/fusb30x/fusb30x.h b/drivers/staging/fusb30x/fusb30x.h
new file mode 100644
index 0000000000000..4f5ca64f72266
--- /dev/null
+++ b/drivers/staging/fusb30x/fusb30x.h
@@ -0,0 +1,552 @@
+/*
+ * Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Zain Wang <zain.wang@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * Some ideas are from chrome ec and fairchild GPL fusb302 driver.
+ */
+
+#ifndef FUSB302_H
+#define FUSB302_H
+
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+
+const char *FUSB_DT_INTERRUPT_INTN =	"fsc_interrupt_int_n";
+#define FUSB_DT_GPIO_INTN		"fairchild,int_n"
+#define FUSB_DT_GPIO_VBUS_5V		"fairchild,vbus5v"
+#define FUSB_DT_GPIO_VBUS_OTHER		"fairchild,vbusOther"
+
+#define FUSB30X_I2C_DRIVER_NAME		"fusb302"
+#define FUSB30X_I2C_DEVICETREE_NAME	"fairchild,fusb302"
+
+/* FUSB300 Register Addresses */
+#define FUSB_REG_DEVICEID		0x01
+#define FUSB_REG_SWITCHES0		0x02
+#define FUSB_REG_SWITCHES1		0x03
+#define FUSB_REG_MEASURE		0x04
+#define FUSB_REG_SLICE			0x05
+#define FUSB_REG_CONTROL0		0x06
+#define FUSB_REG_CONTROL1		0x07
+#define FUSB_REG_CONTROL2		0x08
+#define FUSB_REG_CONTROL3		0x09
+#define FUSB_REG_MASK			0x0A
+#define FUSB_REG_POWER			0x0B
+#define FUSB_REG_RESET			0x0C
+#define FUSB_REG_OCPREG			0x0D
+#define FUSB_REG_MASKA			0x0E
+#define FUSB_REG_MASKB			0x0F
+#define FUSB_REG_CONTROL4		0x10
+#define FUSB_REG_STATUS0A		0x3C
+#define FUSB_REG_STATUS1A		0x3D
+#define FUSB_REG_INTERRUPTA		0x3E
+#define FUSB_REG_INTERRUPTB		0x3F
+#define FUSB_REG_STATUS0		0x40
+#define FUSB_REG_STATUS1		0x41
+#define FUSB_REG_INTERRUPT		0x42
+#define FUSB_REG_FIFO			0x43
+
+enum connection_state {
+	disabled = 0,
+	error_recovery,
+	unattached,
+	attach_wait_sink,
+	attach_wait_source,
+	attached_source,
+	attached_sink,
+
+	policy_src_startup,
+	policy_src_send_caps,
+	policy_src_discovery,
+	policy_src_negotiate_cap,
+	policy_src_cap_response,
+	policy_src_transition_supply,
+	policy_src_transition_default,
+
+	policy_src_ready,
+	policy_src_get_sink_caps,
+
+	policy_src_send_softrst,
+	policy_src_softrst,
+	policy_src_send_hardrst,
+
+	policy_snk_startup,
+	policy_snk_discovery,
+	policy_snk_wait_caps,
+	policy_snk_evaluate_caps,
+	policy_snk_select_cap,
+	policy_snk_transition_sink,
+	policy_snk_ready,
+
+	policy_snk_send_softrst,
+	policy_snk_softrst,
+	policy_snk_send_hardrst,
+
+	policy_snk_transition_default,
+
+	/* PR SWAP */
+	policy_src_prs_evaluate,
+	policy_src_prs_accept,
+	policy_src_prs_transition_to_off,
+	policy_src_prs_source_off,
+	policy_src_prs_assert_rd,
+	policy_src_prs_reject,
+	policy_src_prs_send_swap,
+
+	policy_snk_prs_evaluate,
+	policy_snk_prs_accept,
+	policy_snk_prs_transition_to_off,
+	policy_snk_prs_source_on,
+	policy_snk_prs_assert_rp,
+	policy_snk_prs_reject,
+	policy_snk_prs_send_swap,
+
+	/* VC SWAP */
+	policy_vcs_dfp_send_swap,
+	policy_vcs_dfp_wait_for_ufp_vconn,
+	policy_vcs_dfp_turn_off_vconn,
+	policy_vcs_dfp_turn_on_vconn,
+	policy_vcs_dfp_send_ps_rdy,
+
+	policy_vcs_ufp_evaluate_swap,
+	policy_vcs_ufp_reject,
+	policy_vcs_ufp_accept,
+	policy_vcs_ufp_wait_for_dfp_vconn,
+	policy_vcs_ufp_turn_off_vconn,
+	policy_vcs_ufp_turn_on_vconn,
+	policy_vcs_ufp_send_ps_rdy,
+
+	policy_drs_ufp_evaluate,
+	policy_drs_ufp_accept,
+	policy_drs_ufp_reject,
+	policy_drs_ufp_change,
+	policy_drs_ufp_send_swap,
+
+	policy_drs_dfp_evaluate,
+	policy_drs_dfp_accept,
+	policy_drs_dfp_reject,
+	policy_drs_dfp_change,
+	policy_drs_dfp_send_swap,
+
+	attach_try_src,
+	attach_try_snk,
+};
+
+enum vdm_state {
+	VDM_STATE_DISCOVERY_ID,
+	VDM_STATE_DISCOVERY_SVID,
+	VDM_STATE_DISCOVERY_MODES,
+	VDM_STATE_ENTER_MODE,
+	VDM_STATE_UPDATE_STATUS,
+	VDM_STATE_DP_CONFIG,
+	VDM_STATE_NOTIFY,
+	VDM_STATE_READY,
+	VDM_STATE_ERR,
+};
+
+enum tcpm_rp_value {
+	TYPEC_RP_USB = 0,
+	TYPEC_RP_1A5 = 1,
+	TYPEC_RP_3A0 = 2,
+	TYPEC_RP_RESERVED = 3,
+};
+
+enum role_mode {
+	ROLE_MODE_NONE,
+	ROLE_MODE_DRP,
+	ROLE_MODE_UFP,
+	ROLE_MODE_DFP,
+	ROLE_MODE_ASS,
+};
+
+#define SBF(s, v)		((s) << (v))
+#define SWITCHES0_PDWN1		SBF(1, 0)
+#define SWITCHES0_PDWN2		SBF(1, 1)
+#define SWITCHES0_MEAS_CC1	SBF(1, 2)
+#define SWITCHES0_MEAS_CC2	SBF(1, 3)
+#define SWITCHES0_VCONN_CC1	SBF(1, 4)
+#define SWITCHES0_VCONN_CC2	SBF(1, 5)
+#define SWITCHES0_PU_EN1	SBF(1, 6)
+#define SWITCHES0_PU_EN2	SBF(1, 7)
+
+#define SWITCHES1_TXCC1		SBF(1, 0)
+#define SWITCHES1_TXCC2		SBF(1, 1)
+#define SWITCHES1_AUTO_CRC	SBF(1, 2)
+#define SWITCHES1_DATAROLE	SBF(1, 4)
+#define SWITCHES1_SPECREV	SBF(3, 5)
+#define SWITCHES1_POWERROLE	SBF(1, 7)
+
+#define MEASURE_MDAC		SBF(0x3f, 0)
+#define MEASURE_VBUS		SBF(1, 6)
+
+#define SLICE_SDAC		SBF(0x3f, 0)
+#define SLICE_SDAC_HYS		SBF(3, 6)
+
+#define CONTROL0_TX_START	SBF(1, 0)
+#define CONTROL0_AUTO_PRE	SBF(1, 1)
+#define CONTROL0_HOST_CUR	SBF(3, 2)
+#define CONTROL0_HOST_CUR_USB		SBF(1, 2)
+#define CONTROL0_HOST_CUR_1A5		SBF(2, 2)
+#define CONTROL0_HOST_CUR_3A0		SBF(3, 2)
+#define CONTROL0_INT_MASK	SBF(1, 5)
+#define CONTROL0_TX_FLUSH	SBF(1, 6)
+
+#define CONTROL1_ENSOP1		SBF(1, 0)
+#define CONTROL1_ENSOP2		SBF(1, 1)
+#define CONTROL1_RX_FLUSH	SBF(1, 2)
+#define CONTROL1_BIST_MODE2	SBF(1, 4)
+#define CONTROL1_ENSOP1DB	SBF(1, 5)
+#define CONTROL1_ENSOP2DB	SBF(1, 6)
+
+#define CONTROL2_TOGGLE		SBF(1, 0)
+#define CONTROL2_MODE		SBF(3, 1)
+#define CONTROL2_MODE_NONE	0
+#define CONTROL2_MODE_DFP	SBF(3, 1)
+#define CONTROL2_MODE_UFP	SBF(2, 1)
+#define CONTROL2_MODE_DRP	SBF(1, 1)
+#define CONTROL2_WAKE_EN	SBF(1, 3)
+#define CONTROL2_TOG_RD_ONLY	SBF(1, 5)
+#define CONTROL2_TOG_SAVE_PWR1	SBF(1, 6)
+#define CONTROL2_TOG_SAVE_PWR2	SBF(1, 7)
+
+#define CONTROL3_AUTO_RETRY	SBF(1, 0)
+#define CONTROL3_N_RETRIES	SBF(3, 1)
+#define CONTROL3_AUTO_SOFTRESET	SBF(1, 3)
+#define CONTROL3_AUTO_HARDRESET	SBF(1, 4)
+#define CONTROL3_SEND_HARDRESET	SBF(1, 6)
+
+#define MASK_M_BC_LVL		SBF(1, 0)
+#define MASK_M_COLLISION	SBF(1, 1)
+#define MASK_M_WAKE		SBF(1, 2)
+#define MASK_M_ALERT		SBF(1, 3)
+#define MASK_M_CRC_CHK		SBF(1, 4)
+#define MASK_M_COMP_CHNG	SBF(1, 5)
+#define MASK_M_ACTIVITY		SBF(1, 6)
+#define MASK_M_VBUSOK		SBF(1, 7)
+
+#define POWER_PWR		SBF(0xf, 0)
+
+#define RESET_SW_RESET		SBF(1, 0)
+#define RESET_PD_RESET		SBF(1, 1)
+
+#define MASKA_M_HARDRST		SBF(1, 0)
+#define MASKA_M_SOFTRST		SBF(1, 1)
+#define MASKA_M_TXSENT		SBF(1, 2)
+#define MASKA_M_HARDSENT	SBF(1, 3)
+#define MASKA_M_RETRYFAIL	SBF(1, 4)
+#define MASKA_M_SOFTFAIL	SBF(1, 5)
+#define MASKA_M_TOGDONE		SBF(1, 6)
+#define MASKA_M_OCP_TEMP	SBF(1, 7)
+
+#define MASKB_M_GCRCSEND	SBF(1, 0)
+
+#define CONTROL4_TOG_USRC_EXIT	SBF(1, 0)
+
+#define MDAC_1P6V		0x26
+
+#define STATUS0A_HARDRST	SBF(1, 0)
+#define STATUS0A_SOFTRST	SBF(1, 1)
+#define STATUS0A_POWER23	SBF(3, 2)
+#define STATUS0A_RETRYFAIL	SBF(1, 4)
+#define STATUS0A_SOFTFAIL	SBF(1, 5)
+#define STATUS0A_TOGDONE	SBF(1, 6)
+#define STATUS0A_M_OCP_TEMP	SBF(1, 7)
+
+#define STATUS1A_RXSOP		SBF(1, 0)
+#define STATUS1A_RXSOP1DB	SBF(1, 1)
+#define STATUS1A_RXSOP2DB	SBF(1, 2)
+#define STATUS1A_TOGSS		SBF(7, 3)
+#define CC_STATE_TOGSS_CC1	SBF(1, 0)
+#define CC_STATE_TOGSS_CC2	SBF(1, 1)
+#define CC_STATE_TOGSS_IS_UFP	SBF(1, 2)
+
+#define INTERRUPTA_HARDRST	SBF(1, 0)
+#define INTERRUPTA_SOFTRST	SBF(1, 1)
+#define INTERRUPTA_TXSENT	SBF(1, 2)
+#define INTERRUPTA_HARDSENT	SBF(1, 3)
+#define INTERRUPTA_RETRYFAIL	SBF(1, 4)
+#define INTERRUPTA_SOFTFAIL	SBF(1, 5)
+#define INTERRUPTA_TOGDONE	SBF(1, 6)
+#define INTERRUPTA_OCP_TEMP	SBF(1, 7)
+
+#define INTERRUPTB_GCRCSENT	SBF(1, 0)
+
+#define STATUS0_BC_LVL		SBF(3, 0)
+#define STATUS0_WAKE		SBF(1, 2)
+#define STATUS0_ALERT		SBF(1, 3)
+#define STATUS0_CRC_CHK		SBF(1, 4)
+#define STATUS0_COMP		SBF(1, 5)
+#define STATUS0_ACTIVITY	SBF(1, 6)
+#define STATUS0_VBUSOK		SBF(1, 7)
+
+#define STATUS1_OCP		SBF(1, 0)
+#define STATUS1_OVRTEMP		SBF(1, 1)
+#define STATUS1_TX_FULL		SBF(1, 2)
+#define STATUS1_TX_EMPTY	SBF(1, 3)
+#define STATUS1_RX_FULL		SBF(1, 4)
+#define STATUS1_RX_EMPTY	SBF(1, 5)
+#define STATUS1_RXSOP1		SBF(1, 6)
+#define STATUS1_RXSOP2		SBF(1, 7)
+
+#define INTERRUPT_BC_LVL	SBF(1, 0)
+#define INTERRUPT_COLLISION	SBF(1, 1)
+#define INTERRUPT_WAKE		SBF(1, 2)
+#define INTERRUPT_ALERT		SBF(1, 3)
+#define INTERRUPT_CRC_CHK	SBF(1, 4)
+#define INTERRUPT_COMP_CHNG	SBF(1, 5)
+#define INTERRUPT_ACTIVITY	SBF(1, 6)
+#define INTERRUPT_VBUSOK	SBF(1, 7)
+
+#define FUSB_TKN_TXON		0xa1
+#define FUSB_TKN_SYNC1		0x12
+#define FUSB_TKN_SYNC2		0x13
+#define FUSB_TKN_SYNC3		0x1b
+#define FUSB_TKN_RST1		0x15
+#define FUSB_TKN_RST2		0x16
+#define FUSB_TKN_PACKSYM	0x80
+#define FUSB_TKN_JAMCRC		0xff
+#define FUSB_TKN_EOP		0x14
+#define FUSB_TKN_TXOFF		0xfe
+
+/* USB PD Control Message Types */
+#define CONTROLMESSAGE		0
+#define CMT_GOODCRC		1
+#define CMT_GOTOMIN		2
+#define CMT_ACCEPT		3
+#define CMT_REJECT		4
+#define CMT_PING		5
+#define CMT_PS_RDY		6
+#define CMT_GETSOURCECAP	7
+#define CMT_GETSINKCAP		8
+#define CMT_DR_SWAP		9
+#define CMT_PR_SWAP		10
+#define CMT_VCONN_SWAP		11
+#define CMT_WAIT		12
+#define CMT_SOFTRESET		13
+
+/* USB PD Data Message Types */
+#define DATAMESSAGE		1
+#define DMT_SOURCECAPABILITIES	1
+#define DMT_REQUEST		2
+#define DMT_BIST		3
+#define DMT_SINKCAPABILITIES	4
+#define DMT_VENDERDEFINED	15
+
+/* VDM Command Types */
+#define VDM_DISCOVERY_ID	0X01
+#define VDM_DISCOVERY_SVIDS	0X02
+#define VDM_DISCOVERY_MODES	0X03
+#define VDM_ENTER_MODE		0X04
+#define VDM_EXIT_MODE		0X05
+#define VDM_ATTENTION		0X06
+#define VDM_DP_STATUS_UPDATE	0X10
+#define VDM_DP_CONFIG		0X11
+
+#define VDM_TYPE_INIT		0
+#define VDM_TYPE_ACK		1
+#define VDM_TYPE_NACK		2
+#define VDM_TYPE_BUSY		3
+
+/* 200ms at least, 1 cycle about 6ms */
+#define N_DEBOUNCE_CNT		33
+#define N_CAPS_COUNT		50
+#define N_HARDRESET_COUNT	0
+
+#define T_NO_RESPONSE		5000
+#define T_SRC_RECOVER		830
+#define T_TYPEC_SEND_SOURCECAP	100
+#define T_SENDER_RESPONSE	30
+#define T_SRC_TRANSITION	30
+#define T_TYPEC_SINK_WAIT_CAP	500
+#define T_PS_TRANSITION		500
+#define T_BMC_TIMEOUT		5
+#define T_PS_HARD_RESET_MAX	35
+#define T_SAFE_0V		650
+#define T_SRC_TURN_ON		275
+#define T_SRC_RECOVER_MAX	1000
+#define T_PD_SOURCE_OFF		920
+#define T_PD_SOURCE_ON		480
+#define T_PD_SWAP_SOURCE_START	20
+#define T_PD_VCONN_SRC_ON	100
+#define T_PD_TRY_DRP		75
+
+#define T_NO_TRIGGER		500
+#define T_DISABLED		0xffff
+
+#define PD_HEADER_CNT(header)		(((header) >> 12) & 7)
+#define PD_HEADER_TYPE(header)		((header) & 0xF)
+#define PD_HEADER_ID(header)		(((header) >> 9) & 7)
+
+#define VDM_HEADER_TYPE(header)		(((header) >> 6) & 3)
+#define VDMHEAD_CMD_TYPE_MASK		(3 << 6)
+#define VDMHEAD_CMD_MASK		(0x1f << 0)
+#define VDMHEAD_STRUCT_TYPE_MASK	BIT(15)
+
+#define GET_VDMHEAD_CMD_TYPE(head)	((head & VDMHEAD_CMD_TYPE_MASK) >> 6)
+#define GET_VDMHEAD_CMD(head)		(head & VDMHEAD_CMD_MASK)
+#define GET_VDMHEAD_STRUCT_TYPE(head)	((head & VDMHEAD_STRUCT_TYPE_MASK) >> 15)
+
+#define DP_STATUS_MASK			0x000000ff
+#define DP_STATUS_HPD_STATE		BIT(7)
+
+#define GET_DP_STATUS(status)		(status & DP_STATUS_MASK)
+#define GET_DP_STATUS_HPD(status)	((status & DP_STATUS_HPD_STATE) >> 7)
+
+#define VDM_IDHEAD_USBVID_MASK		(0xffff << 0)
+#define VDM_IDHEAD_MODALSUPPORT_MASK	BIT(26)
+#define VDM_IDHEAD_PRODUCTTYPE		(7 << 27)
+#define VDM_IDHEAD_USBDEVICE		BIT(30)
+#define VDM_IDHEAD_USBHOST		BIT(30)
+
+#define CAP_POWER_TYPE(PDO)		((PDO >> 30) & 3)
+#define CAP_FPDO_VOLTAGE(PDO)		((PDO >> 10) & 0x3ff)
+#define CAP_VPDO_VOLTAGE(PDO)		((PDO >> 20) & 0x3ff)
+#define CAP_FPDO_CURRENT(PDO)		((PDO >> 0) & 0x3ff)
+#define CAP_VPDO_CURRENT(PDO)		((PDO >> 0) & 0x3ff)
+
+enum CC_ORIENTATION {
+	NONE,
+	CC1,
+	CC2,
+};
+
+enum typec_cc_polarity {
+	TYPEC_POLARITY_CC1,
+	TYPEC_POLARITY_CC2,
+};
+
+enum CC_MODE {
+	CC_PULL_UP,
+	CC_PULL_DOWN,
+	CC_PULL_NONE,
+};
+
+enum typec_power_role {
+	POWER_ROLE_SINK = 0,
+	POWER_ROLE_SOURCE,
+};
+
+enum typec_data_role {
+	DATA_ROLE_UFP = 0,
+	DATA_ROLE_DFP,
+};
+
+struct notify_info {
+	enum CC_ORIENTATION orientation;
+	/* 0 UFP : 1 DFP */
+	enum typec_power_role power_role;
+	enum typec_data_role data_role;
+
+	bool is_cc_connected;
+	bool is_pd_connected;
+
+	bool is_enter_mode;
+	int pin_assignment_support;
+	int pin_assignment_def;
+	bool attention;
+	u32 dp_status;
+	u32 dp_caps;
+};
+
+enum tx_state {
+	tx_idle,
+	tx_busy,
+	tx_failed,
+	tx_success
+};
+
+struct PD_CAP_INFO {
+	u32 peak_current;
+	u32 specification_revision;
+	u32 externally_powered;
+	u32 usb_suspend_support;
+	u32 usb_communications_cap;
+	u32 dual_role_power;
+	u32 data_role_swap;
+	u32 supply_type;
+};
+
+struct fusb30x_chip {
+	struct i2c_client *client;
+	struct device *dev;
+	struct regmap *regmap;
+	struct work_struct work;
+	struct workqueue_struct *fusb30x_wq;
+	struct hrtimer timer_state_machine;
+	struct hrtimer timer_mux_machine;
+	struct PD_CAP_INFO pd_cap_info;
+	struct notify_info notify;
+	struct notify_info notify_cmp;
+	struct extcon_dev *extcon;
+	enum connection_state conn_state;
+	struct gpio_desc *gpio_vbus_5v;
+	struct gpio_desc *gpio_vbus_other;
+	struct gpio_desc *gpio_int;
+	struct gpio_desc *gpio_discharge;
+	int timer_state;
+	int timer_mux;
+	int port_num;
+	u32 work_continue;
+	spinlock_t irq_lock;
+	int gpio_int_irq;
+	int enable_irq;
+
+	/*
+	 * ---------------------------------
+	 * | role 0x03 << 2, | cc_use 0x03 |
+	 * | src  1 << 2,    | cc1 1       |
+	 * | snk  2 << 2,    | cc2 2       |
+	 * ---------------------------------
+	 */
+	u8 cc_state;
+	int cc1;
+	int cc2;
+	enum typec_cc_polarity cc_polarity;
+	u8 val_tmp;
+	u8 debounce_cnt;
+	int sub_state;
+	int caps_counter;
+	u32 send_load[7];
+	u32 rec_load[7];
+	u16 send_head;
+	u16 rec_head;
+	int msg_id;
+	enum tx_state tx_state;
+	int hardrst_count;
+	u32 source_power_supply[7];
+	/* 50mv unit */
+	u32 source_max_current[7];
+	/* 10ma uint*/
+	int pos_power;
+	/*
+	 * if PartnerCap[0] == 0xffffffff
+	 * show Partner Device do not support supply
+	 */
+	u32 partner_cap[7];
+	int n_caps_used;
+	int vdm_state;
+	int vdm_substate;
+	int vdm_send_state;
+	u16 vdm_svid[12];
+	int vdm_svid_num;
+	u32 vdm_id;
+	u8 chip_id;
+	bool vconn_enabled;
+	bool is_pd_support;
+	int pd_output_vol;
+	int pd_output_cur;
+	int cc_meas_high;
+	int cc_meas_low;
+	bool vbus_begin;
+
+	enum role_mode role;
+	bool vconn_supported;
+	bool try_role_complete;
+	enum role_mode try_role;
+};
+
+#endif /* FUSB302_H */
+
-- 
2.32.0


From a527a8f37e9caaf4b1520a8f51ed519cc6940d9f Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:22 -0400
Subject: [PATCH 05/26] [armbian] board-helios64-dts-fix-stability-issues.patch

---
 arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts | 1 +
 1 file changed, 1 insertion(+)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts b/arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts
index 27e6bb476962b..e59b676a88386 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts
@@ -478,6 +478,7 @@ rk808: pmic@1b {
 		pinctrl-names = "default";
 		pinctrl-0 = <&pmic_int_l>;
 		rockchip,system-power-controller;
+		max-buck-steps-per-change = <4>;
 		wakeup-source;
 
 		vcc1-supply = <&vcc5v0_sys>;
-- 
2.32.0


From d66a55580e133d380297d18fd41dbf3d57fcf21f Mon Sep 17 00:00:00 2001
From: Aditya Prayoga <aditya@kobol.io>
Date: Mon, 7 Sep 2020 20:29:43 +0700
Subject: [PATCH 06/26] Remove overclock from helios64

Signed-off-by: Aditya Prayoga <aditya@kobol.io>
---
 arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts b/arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts
index e59b676a88386..93c099fe660a2 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts
@@ -1152,4 +1152,12 @@ &vopl {
 
 &vopl_mmu {
 	status = "okay";
-};
\ No newline at end of file
+};
+
+&cluster0_opp {
+	/delete-node/ opp06;
+};
+
+&cluster1_opp {
+	/delete-node/ opp08;
+};
-- 
2.32.0


From 5da3ef6d5824bdfaa19ba86e83c7c9b783c13c86 Mon Sep 17 00:00:00 2001
From: Aditya Prayoga <aditya@kobol.io>
Date: Tue, 15 Sep 2020 13:42:02 +0700
Subject: [PATCH 07/26] Remove PCIE ep-gpios from Helios64

Signed-off-by: Aditya Prayoga <aditya@kobol.io>
---
 arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts | 1 -
 1 file changed, 1 deletion(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts b/arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts
index 93c099fe660a2..901a7c8279064 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-kobol-helios64.dts
@@ -771,7 +771,6 @@ &io_domains {
 };
 
 &pcie0 {
-	ep-gpios = <&gpio2 RK_PD4 GPIO_ACTIVE_HIGH>;
 	num-lanes = <2>;
 	max-link-speed = <2>;
 	pinctrl-names = "default";
-- 
2.32.0


From 5673c43fd37c84fb65721a5d73e8dd804db7d92d Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:22 -0400
Subject: [PATCH 08/26] [armbian] general-add-dwc3-xhci-usb-trb-quirk.patch

---
 drivers/usb/dwc3/core.c      |  2 ++
 drivers/usb/dwc3/core.h      |  4 ++++
 drivers/usb/dwc3/host.c      |  5 ++++-
 drivers/usb/host/xhci-plat.c |  3 +++
 drivers/usb/host/xhci-ring.c | 17 +++++++++++++++++
 drivers/usb/host/xhci.h      |  5 +++++
 6 files changed, 35 insertions(+), 1 deletion(-)

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index bfb72902f3a68..e87b08cbfd789 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -1368,6 +1368,8 @@ static void dwc3_get_properties(struct dwc3 *dwc)
 				"snps,dis-del-phy-power-chg-quirk");
 	dwc->dis_tx_ipgap_linecheck_quirk = device_property_read_bool(dev,
 				"snps,dis-tx-ipgap-linecheck-quirk");
+	dwc->xhci_trb_ent_quirk = device_property_read_bool(dev,
+				"snps,xhci-trb-ent-quirk");
 	dwc->parkmode_disable_ss_quirk = device_property_read_bool(dev,
 				"snps,parkmode-disable-ss-quirk");
 
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 79e1b82e5e057..1013d1318bf6f 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -1052,6 +1052,9 @@ struct dwc3_scratchpad_array {
  *			change quirk.
  * @dis_tx_ipgap_linecheck_quirk: set if we disable u2mac linestate
  *			check during HS transmit.
+ * @xhci_trb_ent_quirk: set if need to enable the Evaluate Next TRB(ENT)
+			flag in the TRB data structure to force xHC to
+			pre-fetch the next TRB of a TD.
  * @parkmode_disable_ss_quirk: set if we need to disable all SuperSpeed
  *			instances in park mode.
  * @tx_de_emphasis_quirk: set if we enable Tx de-emphasis quirk
@@ -1252,6 +1255,7 @@ struct dwc3 {
 	unsigned		dis_u2_freeclk_exists_quirk:1;
 	unsigned		dis_del_phy_power_chg_quirk:1;
 	unsigned		dis_tx_ipgap_linecheck_quirk:1;
+	unsigned		xhci_trb_ent_quirk:1;
 	unsigned		parkmode_disable_ss_quirk:1;
 
 	unsigned		tx_de_emphasis_quirk:1;
diff --git a/drivers/usb/dwc3/host.c b/drivers/usb/dwc3/host.c
index e195176580de1..19d48703d5d78 100644
--- a/drivers/usb/dwc3/host.c
+++ b/drivers/usb/dwc3/host.c
@@ -44,7 +44,7 @@ static int dwc3_host_get_irq(struct dwc3 *dwc)
 
 int dwc3_host_init(struct dwc3 *dwc)
 {
-	struct property_entry	props[4];
+	struct property_entry	props[5];
 	struct platform_device	*xhci;
 	int			ret, irq;
 	struct resource		*res;
@@ -92,6 +92,9 @@ int dwc3_host_init(struct dwc3 *dwc)
 	if (dwc->usb3_lpm_capable)
 		props[prop_idx++] = PROPERTY_ENTRY_BOOL("usb3-lpm-capable");
 
+	if (dwc->xhci_trb_ent_quirk)
+		props[prop_idx++] = PROPERTY_ENTRY_BOOL("xhci-trb-ent-quirk");
+
 	if (dwc->usb2_lpm_disable)
 		props[prop_idx++] = PROPERTY_ENTRY_BOOL("usb2-lpm-disable");
 
diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
index c1edcc9b13cec..1089e4fe743d3 100644
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@ -323,6 +323,9 @@ static int xhci_plat_probe(struct platform_device *pdev)
 		if (device_property_read_bool(tmpdev, "quirk-broken-port-ped"))
 			xhci->quirks |= XHCI_BROKEN_PORT_PED;
 
+		if (device_property_read_bool(tmpdev, "xhci-trb-ent-quirk"))
+			xhci->quirks |= XHCI_TRB_ENT_QUIRK;
+
 		device_property_read_u32(tmpdev, "imod-interval-ns",
 					 &xhci->imod_interval);
 	}
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index dc2068e3bedb7..e09ffa285cb1b 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -3357,6 +3357,7 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 	bool more_trbs_coming = true;
 	bool need_zero_pkt = false;
 	bool first_trb = true;
+	bool en_trb_ent = true;
 	unsigned int num_trbs;
 	unsigned int start_cycle, num_sgs = 0;
 	unsigned int enqd_len, block_len, trb_buff_len, full_len;
@@ -3393,6 +3394,13 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 	if (urb->transfer_flags & URB_ZERO_PACKET && urb_priv->num_tds > 1)
 		need_zero_pkt = true;
 
+	/*
+	 * Don't enable the ENT flag in the TRB if
+	 * the EP support bulk streaming protocol.
+	 */
+	if (urb->stream_id)
+		en_trb_ent = false;
+
 	td = &urb_priv->td[0];
 
 	/*
@@ -3421,6 +3429,13 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 			first_trb = false;
 			if (start_cycle == 0)
 				field |= TRB_CYCLE;
+			/*
+			 * Don't enable the ENT flag in the TRB if the
+			 * transfer length of the first TRB isn't an
+			 * integer multiple of the EP maxpacket.
+			 */
+			if (trb_buff_len % usb_endpoint_maxp(&urb->ep->desc))
+				en_trb_ent = false;
 		} else
 			field |= ring->cycle_state;
 
@@ -3429,6 +3444,8 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		 */
 		if (enqd_len + trb_buff_len < full_len) {
 			field |= TRB_CHAIN;
+			if (xhci->quirks & XHCI_TRB_ENT_QUIRK && en_trb_ent)
+				field |= TRB_ENT;
 			if (trb_is_link(ring->enqueue + 1)) {
 				if (xhci_align_td(xhci, urb, enqd_len,
 						  &trb_buff_len,
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 1c97c8d81154d..4f5e0b9452cd7 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1516,7 +1516,11 @@ static inline const char *xhci_trb_type_string(u8 type)
 #define TRB_SEGMENT_SIZE	(TRBS_PER_SEGMENT*16)
 #define TRB_SEGMENT_SHIFT	(ilog2(TRB_SEGMENT_SIZE))
 /* TRB buffer pointers can't cross 64KB boundaries */
+#ifdef CONFIG_ARCH_ROCKCHIP
+#define TRB_MAX_BUFF_SHIFT		12
+#else
 #define TRB_MAX_BUFF_SHIFT		16
+#endif
 #define TRB_MAX_BUFF_SIZE	(1 << TRB_MAX_BUFF_SHIFT)
 /* How much data is left before the 64KB boundary? */
 #define TRB_BUFF_LEN_UP_TO_BOUNDARY(addr)	(TRB_MAX_BUFF_SIZE - \
@@ -1832,6 +1836,7 @@ struct xhci_hcd {
 #define XHCI_STATE_HALTED	(1 << 1)
 #define XHCI_STATE_REMOVING	(1 << 2)
 	unsigned long long	quirks;
+#define XHCI_TRB_ENT_QUIRK	BIT_ULL(63)
 #define	XHCI_LINK_TRB_QUIRK	BIT_ULL(0)
 #define XHCI_RESET_EP_QUIRK	BIT_ULL(1)
 #define XHCI_NEC_HOST		BIT_ULL(2)
-- 
2.32.0


From d100f5a04cdbf5769ad7eba4e17ee4e5e79a40ee Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:23 -0400
Subject: [PATCH 09/26] [armbian] general-add-miniDP-dt-doc.patch

---
 .../extcon/extcon-usbc-virtual-pd.yaml        | 66 +++++++++++++++++++
 1 file changed, 66 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/extcon/extcon-usbc-virtual-pd.yaml

diff --git a/Documentation/devicetree/bindings/extcon/extcon-usbc-virtual-pd.yaml b/Documentation/devicetree/bindings/extcon/extcon-usbc-virtual-pd.yaml
new file mode 100644
index 0000000000000..8110fbe2ddc23
--- /dev/null
+++ b/Documentation/devicetree/bindings/extcon/extcon-usbc-virtual-pd.yaml
@@ -0,0 +1,66 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/extcon/extcon-usbc-virtual-pd.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Type-C Virtual PD extcon
+
+maintainers:
+  - Jagan Teki <jagan@amarulasolutions.com>
+
+description: |
+  USB Type-C protocol supports various modes of operations includes PD,
+  USB3, and Altmode. If the platform design supports a Type-C connector
+  then configuring these modes can be done via enumeration.
+
+  However, there are some platforms that design these modes as separate
+  protocol connectors like design Display Port from on-chip USB3 controller.
+  So we can access Type-C Altmode Display Port via onboard Display Port
+  connector instead of a Type-C connector. These kinds of platforms require
+  an explicit extcon driver in order to handle Power Delivery and
+  Port Detection.
+
+properties:
+  compatible:
+    const: linux,extcon-usbc-virtual-pd
+
+  det-gpios:
+    description: Detect GPIO pin. Pin can be Display Port Detect or USB ID.
+    maxItems: 1
+
+  vpd-polarity:
+    description: USB Type-C Polarity. false for Normal and true for Flip.
+    type: boolean
+
+  vpd-super-speed:
+    description: USB Super Speed. false for USB2 and true for USB3.
+    type: boolean
+
+  vpd-data-role:
+    description: USB Data roles for Virtual Type-C.
+    $ref: /schemas/types.yaml#definitions/string
+
+    enum:
+      - host
+      - device
+      - display-port
+
+required:
+  - compatible
+  - det-gpios
+  - vpd-data-role
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+    #include <dt-bindings/pinctrl/rockchip.h>
+
+    virtual_pd: virtual-pd {
+        compatible = "linux,extcon-usbc-virtual-pd";
+        det-gpios = <&gpio4 RK_PD1 GPIO_ACTIVE_LOW>;
+        vpd-data-role = "display-port";
+        vpd-super-speed;
+    };
-- 
2.32.0


From 395633124a39e2ae7cd7d45dddc25cbc730725b1 Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:23 -0400
Subject: [PATCH 10/26] [armbian] general-add-miniDP-virtual-extcon.patch

---
 MAINTAINERS                             |   6 +
 drivers/extcon/Kconfig                  |  10 +
 drivers/extcon/Makefile                 |   1 +
 drivers/extcon/extcon-usbc-virtual-pd.c | 285 ++++++++++++++++++++++++
 4 files changed, 302 insertions(+)
 create mode 100644 drivers/extcon/extcon-usbc-virtual-pd.c

diff --git a/MAINTAINERS b/MAINTAINERS
index 4fef10dd29753..33e108534e993 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -6628,6 +6628,12 @@ F:	Documentation/filesystems/ext4/
 F:	fs/ext4/
 F:	include/trace/events/ext4.h
 
+EXTCON DRIVER FOR TYPE-C VIRTUAL PD
+M:	Jagan Teki <jagan@amarulasolutions.com>
+S:	Maintained
+F:	Documentation/devicetree/bindings/extcon/extcon-usbc-virtual-pd.yaml
+F:	drivers/extcon/extcon-usbc-virtual-pd.c
+
 Extended Verification Module (EVM)
 M:	Mimi Zohar <zohar@linux.ibm.com>
 L:	linux-integrity@vger.kernel.org
diff --git a/drivers/extcon/Kconfig b/drivers/extcon/Kconfig
index aac507bff135c..edd6c3c526993 100644
--- a/drivers/extcon/Kconfig
+++ b/drivers/extcon/Kconfig
@@ -186,4 +186,14 @@ config EXTCON_USBC_CROS_EC
 	  Say Y here to enable USB Type C cable detection extcon support when
 	  using Chrome OS EC based USB Type-C ports.
 
+config EXTCON_USBC_VIRTUAL_PD
+	tristate "Virtual Type-C PD EXTCON support"
+	depends on GPIOLIB || COMPILE_TEST
+	help
+	  Say Y here to enable Virtual Type-C PD extcon driver support, if
+	  hardware platform designed Type-C modes separately.
+
+	  Example, of designing Display Port separately from Type-C Altmode
+	  instead of accessing Altmode Display Port in Type-C connector.
+
 endif
diff --git a/drivers/extcon/Makefile b/drivers/extcon/Makefile
index 52096fd8a216c..c35191eef0e17 100644
--- a/drivers/extcon/Makefile
+++ b/drivers/extcon/Makefile
@@ -25,3 +25,4 @@ obj-$(CONFIG_EXTCON_RT8973A)	+= extcon-rt8973a.o
 obj-$(CONFIG_EXTCON_SM5502)	+= extcon-sm5502.o
 obj-$(CONFIG_EXTCON_USB_GPIO)	+= extcon-usb-gpio.o
 obj-$(CONFIG_EXTCON_USBC_CROS_EC) += extcon-usbc-cros-ec.o
+obj-$(CONFIG_EXTCON_USBC_VIRTUAL_PD) += extcon-usbc-virtual-pd.o
diff --git a/drivers/extcon/extcon-usbc-virtual-pd.c b/drivers/extcon/extcon-usbc-virtual-pd.c
new file mode 100644
index 0000000000000..e0713670e33d8
--- /dev/null
+++ b/drivers/extcon/extcon-usbc-virtual-pd.c
@@ -0,0 +1,285 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Type-C Virtual PD Extcon driver
+ *
+ * Copyright (c) 2019 Fuzhou Rockchip Electronics Co., Ltd
+ * Copyright (c) 2019 Radxa Limited
+ * Copyright (c) 2019 Amarula Solutions(India)
+ */
+
+#include <linux/extcon-provider.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+static const unsigned int vpd_cable[] = {
+	EXTCON_USB,
+	EXTCON_USB_HOST,
+	EXTCON_DISP_DP,
+	EXTCON_NONE,
+};
+
+enum vpd_data_role {
+	DR_NONE,
+	DR_HOST,
+	DR_DEVICE,
+	DR_DISPLAY_PORT,
+};
+
+enum vpd_polarity {
+	POLARITY_NORMAL,
+	POLARITY_FLIP,
+};
+
+enum vpd_usb_ss {
+	USB_SS_USB2,
+	USB_SS_USB3,
+};
+
+struct vpd_extcon {
+	struct device *dev;
+	struct extcon_dev *extcon;
+	struct gpio_desc *det_gpio;
+
+	u8 polarity;
+	u8 usb_ss;
+	enum vpd_data_role data_role;
+
+	int irq;
+	bool enable_irq;
+	struct work_struct work;
+	struct delayed_work irq_work;
+};
+
+static void vpd_extcon_irq_work(struct work_struct *work)
+{
+	struct vpd_extcon *vpd = container_of(work, struct vpd_extcon, irq_work.work);
+	bool host_connected = false, device_connected = false, dp_connected = false;
+	union extcon_property_value property;
+	int det;
+
+	det = vpd->det_gpio ? gpiod_get_raw_value(vpd->det_gpio) : 0;
+	if (det) {
+		device_connected = (vpd->data_role == DR_DEVICE) ? true : false;
+		host_connected = (vpd->data_role == DR_HOST) ? true : false;
+		dp_connected = (vpd->data_role == DR_DISPLAY_PORT) ? true : false;
+	}
+
+	extcon_set_state(vpd->extcon, EXTCON_USB, host_connected);
+	extcon_set_state(vpd->extcon, EXTCON_USB_HOST, device_connected);
+	extcon_set_state(vpd->extcon, EXTCON_DISP_DP, dp_connected);
+
+	property.intval = vpd->polarity;
+	extcon_set_property(vpd->extcon, EXTCON_USB,
+			    EXTCON_PROP_USB_TYPEC_POLARITY, property);
+	extcon_set_property(vpd->extcon, EXTCON_USB_HOST,
+			    EXTCON_PROP_USB_TYPEC_POLARITY, property);
+	extcon_set_property(vpd->extcon, EXTCON_DISP_DP,
+			    EXTCON_PROP_USB_TYPEC_POLARITY, property);
+
+	property.intval = vpd->usb_ss;
+	extcon_set_property(vpd->extcon, EXTCON_USB,
+			    EXTCON_PROP_USB_SS, property);
+	extcon_set_property(vpd->extcon, EXTCON_USB_HOST,
+			    EXTCON_PROP_USB_SS, property);
+	extcon_set_property(vpd->extcon, EXTCON_DISP_DP,
+			    EXTCON_PROP_USB_SS, property);
+
+	extcon_sync(vpd->extcon, EXTCON_USB);
+	extcon_sync(vpd->extcon, EXTCON_USB_HOST);
+	extcon_sync(vpd->extcon, EXTCON_DISP_DP);
+}
+
+static irqreturn_t vpd_extcon_irq_handler(int irq, void *dev_id)
+{
+	struct vpd_extcon *vpd = dev_id;
+
+	schedule_delayed_work(&vpd->irq_work, msecs_to_jiffies(10));
+
+	return IRQ_HANDLED;
+}
+
+static enum vpd_data_role vpd_extcon_data_role(struct vpd_extcon *vpd)
+{
+	const char *const data_roles[] = {
+		[DR_NONE]		= "NONE",
+		[DR_HOST]		= "host",
+		[DR_DEVICE]		= "device",
+		[DR_DISPLAY_PORT]	= "display-port",
+	};
+	struct device *dev = vpd->dev;
+	int ret;
+	const char *dr;
+
+	ret = device_property_read_string(dev, "vpd-data-role", &dr);
+	if (ret < 0)
+		return DR_NONE;
+
+	ret = match_string(data_roles, ARRAY_SIZE(data_roles), dr);
+
+	return (ret < 0) ? DR_NONE : ret;
+}
+
+static int vpd_extcon_parse_dts(struct vpd_extcon *vpd)
+{
+	struct device *dev = vpd->dev;
+	bool val = false;
+	int ret;
+
+	val = device_property_read_bool(dev, "vpd-polarity");
+	if (val)
+		vpd->polarity = POLARITY_FLIP;
+	else
+		vpd->polarity = POLARITY_NORMAL;
+
+	val = device_property_read_bool(dev, "vpd-super-speed");
+	if (val)
+		vpd->usb_ss = USB_SS_USB3;
+	else
+		vpd->usb_ss = USB_SS_USB2;
+
+	vpd->data_role = vpd_extcon_data_role(vpd);
+
+	vpd->det_gpio = devm_gpiod_get_optional(dev, "det", GPIOD_OUT_LOW);
+	if (IS_ERR(vpd->det_gpio)) {
+		ret = PTR_ERR(vpd->det_gpio);
+		dev_warn(dev, "failed to get det gpio: %d\n", ret);
+		return ret;
+	}
+
+	vpd->irq = gpiod_to_irq(vpd->det_gpio);
+	if (vpd->irq < 0) {
+		dev_err(dev, "failed to get irq for gpio: %d\n", vpd->irq);
+		return vpd->irq;
+	}
+
+	ret = devm_request_threaded_irq(dev, vpd->irq, NULL,
+					vpd_extcon_irq_handler,
+					IRQF_TRIGGER_FALLING |
+					IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+					NULL, vpd);
+	if (ret)
+		dev_err(dev, "failed to request gpio irq\n");
+
+	return ret;
+}
+
+static int vpd_extcon_probe(struct platform_device *pdev)
+{
+	struct vpd_extcon *vpd;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	vpd = devm_kzalloc(dev, sizeof(*vpd), GFP_KERNEL);
+	if (!vpd)
+		return -ENOMEM;
+
+	vpd->dev = dev;
+	ret = vpd_extcon_parse_dts(vpd);
+	if (ret)
+		return ret;
+
+	INIT_DELAYED_WORK(&vpd->irq_work, vpd_extcon_irq_work);
+
+	vpd->extcon = devm_extcon_dev_allocate(dev, vpd_cable);
+	if (IS_ERR(vpd->extcon)) {
+		dev_err(dev, "allocat extcon failed\n");
+		return PTR_ERR(vpd->extcon);
+	}
+
+	ret = devm_extcon_dev_register(dev, vpd->extcon);
+	if (ret) {
+		dev_err(dev, "register extcon failed: %d\n", ret);
+		return ret;
+	}
+
+	extcon_set_property_capability(vpd->extcon, EXTCON_USB,
+				       EXTCON_PROP_USB_VBUS);
+	extcon_set_property_capability(vpd->extcon, EXTCON_USB_HOST,
+				       EXTCON_PROP_USB_VBUS);
+
+	extcon_set_property_capability(vpd->extcon, EXTCON_USB,
+				       EXTCON_PROP_USB_TYPEC_POLARITY);
+	extcon_set_property_capability(vpd->extcon, EXTCON_USB_HOST,
+				       EXTCON_PROP_USB_TYPEC_POLARITY);
+	extcon_set_property_capability(vpd->extcon, EXTCON_USB,
+				       EXTCON_PROP_USB_SS);
+	extcon_set_property_capability(vpd->extcon, EXTCON_USB_HOST,
+				       EXTCON_PROP_USB_SS);
+
+	extcon_set_property_capability(vpd->extcon, EXTCON_DISP_DP,
+				       EXTCON_PROP_USB_SS);
+	extcon_set_property_capability(vpd->extcon, EXTCON_DISP_DP,
+				       EXTCON_PROP_USB_TYPEC_POLARITY);
+
+	platform_set_drvdata(pdev, vpd);
+
+	vpd_extcon_irq_work(&vpd->irq_work.work);
+
+	return 0;
+}
+
+static int vpd_extcon_remove(struct platform_device *pdev)
+{
+	struct vpd_extcon *vpd = platform_get_drvdata(pdev);
+
+	cancel_delayed_work_sync(&vpd->irq_work);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int vpd_extcon_suspend(struct device *dev)
+{
+	struct vpd_extcon *vpd = dev_get_drvdata(dev);
+
+	if (!vpd->enable_irq) {
+		disable_irq_nosync(vpd->irq);
+		vpd->enable_irq = true;
+	}
+
+	return 0;
+}
+
+static int vpd_extcon_resume(struct device *dev)
+{
+	struct vpd_extcon *vpd = dev_get_drvdata(dev);
+
+	if (vpd->enable_irq) {
+		enable_irq(vpd->irq);
+		vpd->enable_irq = false;
+	}
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(vpd_extcon_pm_ops,
+			 vpd_extcon_suspend, vpd_extcon_resume);
+
+static const struct of_device_id vpd_extcon_dt_match[] = {
+	{ .compatible = "linux,extcon-usbc-virtual-pd", },
+	{ /* sentinel */ }
+};
+
+static struct platform_driver vpd_extcon_driver = {
+	.probe		= vpd_extcon_probe,
+	.remove		= vpd_extcon_remove,
+	.driver		= {
+		.name	= "extcon-usbc-virtual-pd",
+		.pm	= &vpd_extcon_pm_ops,
+		.of_match_table = vpd_extcon_dt_match,
+	},
+};
+
+module_platform_driver(vpd_extcon_driver);
+
+MODULE_AUTHOR("Jagan Teki <jagan@amarulasolutions.com>");
+MODULE_DESCRIPTION("Type-C Virtual PD extcon driver");
+MODULE_LICENSE("GPL v2");
-- 
2.32.0


From 985efa4532a8b3899da62dbdfa4544833abf7791 Mon Sep 17 00:00:00 2001
From: microcai <microcaicai@gmail.com>
Date: Mon, 29 Jun 2020 23:36:40 +0800
Subject: [PATCH 11/26] spi-nor: Add support for xt25f32b/xt25f128b

The RockPi4b dev board ship with xt25f32b solded. add these ids so the
board's spi flash can be accessed within linux.

Signed-off-by: microcai <microcaicai@gmail.com>
---
 drivers/mtd/spi-nor/Makefile |  1 +
 drivers/mtd/spi-nor/core.c   |  1 +
 drivers/mtd/spi-nor/core.h   |  1 +
 drivers/mtd/spi-nor/xtx.c    | 21 +++++++++++++++++++++
 4 files changed, 24 insertions(+)
 create mode 100644 drivers/mtd/spi-nor/xtx.c

diff --git a/drivers/mtd/spi-nor/Makefile b/drivers/mtd/spi-nor/Makefile
index 653923896205c..3f7a52d7fa0b4 100644
--- a/drivers/mtd/spi-nor/Makefile
+++ b/drivers/mtd/spi-nor/Makefile
@@ -17,6 +17,7 @@ spi-nor-objs			+= sst.o
 spi-nor-objs			+= winbond.o
 spi-nor-objs			+= xilinx.o
 spi-nor-objs			+= xmc.o
+spi-nor-objs			+= xtx.o
 obj-$(CONFIG_MTD_SPI_NOR)	+= spi-nor.o
 
 obj-$(CONFIG_MTD_SPI_NOR)	+= controllers/
diff --git a/drivers/mtd/spi-nor/core.c b/drivers/mtd/spi-nor/core.c
index 2b26a875a8550..e71414da979c2 100644
--- a/drivers/mtd/spi-nor/core.c
+++ b/drivers/mtd/spi-nor/core.c
@@ -2026,6 +2026,7 @@ static const struct spi_nor_manufacturer *manufacturers[] = {
 	&spi_nor_winbond,
 	&spi_nor_xilinx,
 	&spi_nor_xmc,
+	&spi_nor_xtx,
 };
 
 static const struct flash_info *
diff --git a/drivers/mtd/spi-nor/core.h b/drivers/mtd/spi-nor/core.h
index 6f62ee861231a..e20710d3c3770 100644
--- a/drivers/mtd/spi-nor/core.h
+++ b/drivers/mtd/spi-nor/core.h
@@ -398,6 +398,7 @@ extern const struct spi_nor_manufacturer spi_nor_sst;
 extern const struct spi_nor_manufacturer spi_nor_winbond;
 extern const struct spi_nor_manufacturer spi_nor_xilinx;
 extern const struct spi_nor_manufacturer spi_nor_xmc;
+extern const struct spi_nor_manufacturer spi_nor_xtx;
 
 int spi_nor_write_enable(struct spi_nor *nor);
 int spi_nor_write_disable(struct spi_nor *nor);
diff --git a/drivers/mtd/spi-nor/xtx.c b/drivers/mtd/spi-nor/xtx.c
new file mode 100644
index 0000000000000..541fd8e52b793
--- /dev/null
+++ b/drivers/mtd/spi-nor/xtx.c
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2005, Intec Automation Inc.
+ * Copyright (C) 2014, Freescale Semiconductor, Inc.
+ */
+
+#include <linux/mtd/spi-nor.h>
+
+#include "core.h"
+
+static const struct flash_info xtx_parts[] = {
+ /* XTX (Shenzhen Xin Tian Xia Tech) */
+ { "xt25f32b", INFO(0x0b4016, 0, 64 * 1024, 64, SECT_4K) },
+ { "xt25f128b", INFO(0x0b4018, 0, 64 * 1024, 256, SECT_4K) },
+};
+
+const struct spi_nor_manufacturer spi_nor_xtx = {
+ .name = "xtx",
+ .parts = xtx_parts,
+ .nparts = ARRAY_SIZE(xtx_parts),
+};
-- 
2.32.0


From ddf3b5f5ef6ce34d2ca597473928f0f53b0835d2 Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:24 -0400
Subject: [PATCH 12/26] [armbian] general-btsdio-ignore-uart-devs.patch

---
 drivers/bluetooth/btsdio.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/bluetooth/btsdio.c b/drivers/bluetooth/btsdio.c
index 199e8f7d426d9..795be33f2892d 100644
--- a/drivers/bluetooth/btsdio.c
+++ b/drivers/bluetooth/btsdio.c
@@ -295,6 +295,8 @@ static int btsdio_probe(struct sdio_func *func,
 		switch (func->device) {
 		case SDIO_DEVICE_ID_BROADCOM_43341:
 		case SDIO_DEVICE_ID_BROADCOM_43430:
+		case SDIO_DEVICE_ID_BROADCOM_4345:
+		case SDIO_DEVICE_ID_BROADCOM_43455:
 		case SDIO_DEVICE_ID_BROADCOM_4356:
 			return -ENODEV;
 		}
-- 
2.32.0


From 10d04b5b97dc6bbe75f20a63102826e90f8b63e2 Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:24 -0400
Subject: [PATCH 13/26] [armbian] general-disable-mtu-validation.patch

---
 drivers/net/ethernet/stmicro/stmmac/stmmac_main.c | 12 ------------
 1 file changed, 12 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 3134f7e669f80..18e48c9d505d3 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -4024,25 +4024,13 @@ static void stmmac_set_rx_mode(struct net_device *dev)
 static int stmmac_change_mtu(struct net_device *dev, int new_mtu)
 {
 	struct stmmac_priv *priv = netdev_priv(dev);
-	int txfifosz = priv->plat->tx_fifo_size;
 	const int mtu = new_mtu;
 
-	if (txfifosz == 0)
-		txfifosz = priv->dma_cap.tx_fifo_size;
-
-	txfifosz /= priv->plat->tx_queues_to_use;
-
 	if (netif_running(dev)) {
 		netdev_err(priv->dev, "must be stopped to change its MTU\n");
 		return -EBUSY;
 	}
 
-	new_mtu = STMMAC_ALIGN(new_mtu);
-
-	/* If condition true, FIFO is too small or MTU too large */
-	if ((txfifosz < new_mtu) || (new_mtu > BUF_SIZE_16KiB))
-		return -EINVAL;
-
 	dev->mtu = mtu;
 
 	netdev_update_features(dev);
-- 
2.32.0


From adcf9bf0d9f446ff7c2e7afca374aaeb7d55c684 Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:24 -0400
Subject: [PATCH 14/26] [armbian] general-emmc-hs400es-init-tweak.patch

---
 drivers/mmc/core/mmc.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 7494d595035e3..e9a9d0e6d295c 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -1379,12 +1379,12 @@ static int mmc_select_hs400es(struct mmc_card *card)
 	}
 
 	mmc_set_timing(host, MMC_TIMING_MMC_HS);
+	mmc_set_clock(host, card->ext_csd.hs_max_dtr);
+
 	err = mmc_switch_status(card, true);
 	if (err)
 		goto out_err;
 
-	mmc_set_clock(host, card->ext_csd.hs_max_dtr);
-
 	/* Switch card to DDR with strobe bit */
 	val = EXT_CSD_DDR_BUS_WIDTH_8 | EXT_CSD_BUS_WIDTH_STROBE;
 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-- 
2.32.0


From ff2670178de6ef109070359a05d0706d9fbbbb37 Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:24 -0400
Subject: [PATCH 15/26] [armbian] general-fix-es8316-kernel-panic.patch

---
 sound/soc/codecs/es8316.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sound/soc/codecs/es8316.c b/sound/soc/codecs/es8316.c
index 609459077f9d9..04fd0cdd3ba0e 100644
--- a/sound/soc/codecs/es8316.c
+++ b/sound/soc/codecs/es8316.c
@@ -683,7 +683,7 @@ static void es8316_disable_jack_detect(struct snd_soc_component *component)
 	snd_soc_component_update_bits(component, ES8316_GPIO_DEBOUNCE,
 				      ES8316_GPIO_ENABLE_INTERRUPT, 0);
 
-	if (es8316->jack->status & SND_JACK_MICROPHONE) {
+	if (es8316->jack && (es8316->jack->status & SND_JACK_MICROPHONE)) {
 		es8316_disable_micbias_for_mic_gnd_short_detect(component);
 		snd_soc_jack_report(es8316->jack, 0, SND_JACK_BTN_0);
 	}
-- 
2.32.0


From 28bb45342a70c0d7d888239b9915916803bd9587 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sun, 17 Feb 2019 22:14:38 +0000
Subject: [PATCH 16/26] mmc: core: set initial signal voltage on power off

Some boards have SD card connectors where the power rail cannot be switched
off by the driver. If the card has not been power cycled, it may still be
using 1.8V signaling after a warm re-boot. Bootroms expecting 3.3V signaling
will fail to boot from a UHS card that continue to use 1.8V signaling.

Set initial signal voltage in mmc_power_off() to allow re-boot to function.

This fixes re-boot with UHS cards on Asus Tinker Board (Rockchip RK3288),
same issue have been seen on some Rockchip RK3399 boards.

I am sending this as a RFC because I have no insights into SD/MMC subsystem,
this change fix a re-boot issue on my boards and does not break emmc/sdio.
Is this an acceptable workaround? Any advice is appreciated.

Signed-off-by: Jonas Karlman <jonas@kwiboo.se>
---
 drivers/mmc/core/core.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b5f3f160c8420..6eb76c6cfd45c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1352,6 +1352,14 @@ void mmc_power_off(struct mmc_host *host)
 	if (host->ios.power_mode == MMC_POWER_OFF)
 		return;
 
+	mmc_set_initial_signal_voltage(host);
+
+	/*
+	 * This delay should be sufficient to allow the power supply
+	 * to reach the minimum voltage.
+	 */
+	mmc_delay(host->ios.power_delay_ms);
+
 	mmc_pwrseq_power_off(host);
 
 	host->ios.clock = 0;
-- 
2.32.0


From 8773b11301360e4a84f508e80116cb74fb8ef30d Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:25 -0400
Subject: [PATCH 17/26] [armbian]
 general-increasing_DMA_block_memory_allocation_to_2048.patch

---
 kernel/dma/pool.c | 8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)

diff --git a/kernel/dma/pool.c b/kernel/dma/pool.c
index d4637f72239b4..cad0fc6636a77 100644
--- a/kernel/dma/pool.c
+++ b/kernel/dma/pool.c
@@ -192,13 +192,11 @@ static int __init dma_atomic_pool_init(void)
 	int ret = 0;
 
 	/*
-	 * If coherent_pool was not used on the command line, default the pool
-	 * sizes to 128KB per 1GB of memory, min 128KB, max MAX_ORDER-1.
+	 * Always use 2MiB as default pool size.
+	 * See: https://forum.armbian.com/topic/4811-uas-mainline-kernel-coherent-pool-memory-size/
 	 */
 	if (!atomic_pool_size) {
-		unsigned long pages = totalram_pages() / (SZ_1G / SZ_128K);
-		pages = min_t(unsigned long, pages, MAX_ORDER_NR_PAGES);
-		atomic_pool_size = max_t(size_t, pages << PAGE_SHIFT, SZ_128K);
+		atomic_pool_size = SZ_2M;
 	}
 	INIT_WORK(&atomic_pool_work, atomic_pool_work_fn);
 
-- 
2.32.0


From eef348ff44fc7898f6780a0161f2c10470bf4878 Mon Sep 17 00:00:00 2001
From: Piotr Szczepanik <piter75@gmail.com>
Date: Sun, 24 Jan 2021 16:14:06 +0100
Subject: [PATCH 18/26] add possibility of disabling rk808-rtc

To disable rk808-rtc driver from loading for specific board
add the following stanza to rk808 node in device tree:

	rtc {
		compatible = "rk808-rtc";
		status = "disabled";
	}

This is needed for roc-rk3399-pc plus (a.k.a. Station P1).
Without the change rk808's rtc is initialised and used for time keeping
although there is another rtc (hym8563) that should be actually used.

Signed-off-by: Piotr Szczepanik <piter75@gmail.com>
---
 drivers/mfd/mfd-core.c | 2 +-
 drivers/mfd/rk808.c    | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/drivers/mfd/mfd-core.c b/drivers/mfd/mfd-core.c
index fc00aaccb5f72..5c13cc9e283ce 100644
--- a/drivers/mfd/mfd-core.c
+++ b/drivers/mfd/mfd-core.c
@@ -225,7 +225,7 @@ static int mfd_add_device(struct device *parent, int id,
 		}
 
 		if (!pdev->dev.of_node)
-			pr_warn("%s: Failed to locate of_node [id: %d]\n",
+			pr_debug("%s: Failed to locate of_node [id: %d]\n",
 				cell->name, platform_id);
 	}
 
diff --git a/drivers/mfd/rk808.c b/drivers/mfd/rk808.c
index d109b9f144070..d90c45cd5aca8 100644
--- a/drivers/mfd/rk808.c
+++ b/drivers/mfd/rk808.c
@@ -145,6 +145,7 @@ static const struct mfd_cell rk808s[] = {
 	{ .name = "rk808-regulator", },
 	{
 		.name = "rk808-rtc",
+		.of_compatible = "rk808-rtc",
 		.num_resources = ARRAY_SIZE(rtc_resources),
 		.resources = rtc_resources,
 	},
-- 
2.32.0


From 915efc1d6333588431a893d61e091432c0d20f6e Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:25 -0400
Subject: [PATCH 19/26] [armbian]
 general-rk808-configrable-switch-voltage-steps.patch

---
 drivers/regulator/rk808-regulator.c | 17 +++++++++++++----
 1 file changed, 13 insertions(+), 4 deletions(-)

diff --git a/drivers/regulator/rk808-regulator.c b/drivers/regulator/rk808-regulator.c
index e926c1a858460..296e143448116 100644
--- a/drivers/regulator/rk808-regulator.c
+++ b/drivers/regulator/rk808-regulator.c
@@ -156,6 +156,7 @@
 
 struct rk808_regulator_data {
 	struct gpio_desc *dvs_gpio[2];
+	unsigned max_buck_steps_per_change;
 };
 
 static const int rk808_buck_config_regs[] = {
@@ -239,7 +240,8 @@ static int rk808_buck1_2_get_voltage_sel_regmap(struct regulator_dev *rdev)
 }
 
 static int rk808_buck1_2_i2c_set_voltage_sel(struct regulator_dev *rdev,
-					     unsigned sel)
+					     unsigned sel,
+					     int max_steps)
 {
 	int ret, delta_sel;
 	unsigned int old_sel, tmp, val, mask = rdev->desc->vsel_mask;
@@ -258,8 +260,8 @@ static int rk808_buck1_2_i2c_set_voltage_sel(struct regulator_dev *rdev,
 	 * the risk of overshoot. Put it into a multi-step, can effectively
 	 * avoid this problem, a step is 100mv here.
 	 */
-	while (delta_sel > MAX_STEPS_ONE_TIME) {
-		old_sel += MAX_STEPS_ONE_TIME;
+	while (delta_sel > max_steps) {
+		old_sel += max_steps;
 		val = old_sel << (ffs(mask) - 1);
 		val |= tmp;
 
@@ -293,12 +295,13 @@ static int rk808_buck1_2_set_voltage_sel(struct regulator_dev *rdev,
 	struct rk808_regulator_data *pdata = rdev_get_drvdata(rdev);
 	int id = rdev_get_id(rdev);
 	struct gpio_desc *gpio = pdata->dvs_gpio[id];
+	int max_steps = pdata->max_buck_steps_per_change;
 	unsigned int reg = rdev->desc->vsel_reg;
 	unsigned old_sel;
 	int ret, gpio_level;
 
 	if (!gpio)
-		return rk808_buck1_2_i2c_set_voltage_sel(rdev, sel);
+		return rk808_buck1_2_i2c_set_voltage_sel(rdev, sel, max_steps);
 
 	gpio_level = gpiod_get_value(gpio);
 	if (gpio_level == 0) {
@@ -1292,6 +1295,12 @@ static int rk808_regulator_dt_parse_pdata(struct device *dev,
 				0 : tmp);
 	}
 
+	tmp = of_property_read_u32(client_dev->of_node, "max-buck-steps-per-change", &pdata->max_buck_steps_per_change);
+	if (tmp) {
+		pdata->max_buck_steps_per_change = MAX_STEPS_ONE_TIME;
+	}
+	dev_info(dev, "max buck steps per change: %d\n", pdata->max_buck_steps_per_change);
+
 dt_parse_end:
 	of_node_put(np);
 	return ret;
-- 
2.32.0


From 12c434719e8fa2aaf0d993ee88b5456f49575969 Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:26 -0400
Subject: [PATCH 20/26] [armbian] general-rt5651-add-mclk.patch

---
 sound/soc/codecs/rt5651.c | 16 ++++++++++++++++
 sound/soc/codecs/rt5651.h |  1 +
 2 files changed, 17 insertions(+)

diff --git a/sound/soc/codecs/rt5651.c b/sound/soc/codecs/rt5651.c
index e59fdc81dbd45..4982c0e83ac01 100644
--- a/sound/soc/codecs/rt5651.c
+++ b/sound/soc/codecs/rt5651.c
@@ -24,6 +24,7 @@
 #include <sound/initval.h>
 #include <sound/tlv.h>
 #include <sound/jack.h>
+#include <linux/clk.h>
 
 #include "rl6231.h"
 #include "rt5651.h"
@@ -1511,6 +1512,7 @@ static int rt5651_set_dai_pll(struct snd_soc_dai *dai, int pll_id, int source,
 static int rt5651_set_bias_level(struct snd_soc_component *component,
 			enum snd_soc_bias_level level)
 {
+	struct rt5651_priv *rt5651 = snd_soc_component_get_drvdata(component);
 	switch (level) {
 	case SND_SOC_BIAS_PREPARE:
 		if (SND_SOC_BIAS_STANDBY == snd_soc_component_get_bias_level(component)) {
@@ -1518,6 +1520,13 @@ static int rt5651_set_bias_level(struct snd_soc_component *component,
 				snd_soc_component_update_bits(component, RT5651_D_MISC,
 						    0xc00, 0xc00);
 		}
+		if (!IS_ERR(rt5651->mclk)){
+			if (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_ON) {
+				clk_disable_unprepare(rt5651->mclk);
+			} else {
+				clk_prepare_enable(rt5651->mclk);
+			}
+		}
 		break;
 	case SND_SOC_BIAS_STANDBY:
 		if (SND_SOC_BIAS_OFF == snd_soc_component_get_bias_level(component)) {
@@ -2059,6 +2068,13 @@ static int rt5651_probe(struct snd_soc_component *component)
 {
 	struct rt5651_priv *rt5651 = snd_soc_component_get_drvdata(component);
 
+	/* Check if MCLK provided */
+	rt5651->mclk = devm_clk_get(component->dev, "mclk");
+	if (PTR_ERR(rt5651->mclk) == -EPROBE_DEFER){
+		dev_err(component->dev, "unable to get mclk\n");
+		return -EPROBE_DEFER;
+	}
+
 	rt5651->component = component;
 
 	snd_soc_component_update_bits(component, RT5651_PWR_ANLG1,
diff --git a/sound/soc/codecs/rt5651.h b/sound/soc/codecs/rt5651.h
index 20c33a3ece370..17524fa9fdfc0 100644
--- a/sound/soc/codecs/rt5651.h
+++ b/sound/soc/codecs/rt5651.h
@@ -2097,6 +2097,7 @@ struct rt5651_priv {
 
 	int dmic_en;
 	bool hp_mute;
+	struct clk *mclk;
 };
 
 #endif /* __RT5651_H__ */
-- 
2.32.0


From 3d92cf7fc4ffc88ddb9814c4ce05d67dcd4fce7a Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:26 -0400
Subject: [PATCH 21/26] [armbian] rk3399-add-sclk-i2sout-src-clock.patch

---
 drivers/clk/rockchip/clk-rk3399.c      | 2 +-
 include/dt-bindings/clock/rk3399-cru.h | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/drivers/clk/rockchip/clk-rk3399.c b/drivers/clk/rockchip/clk-rk3399.c
index 7df2f1e00347e..bb586e3f041d2 100644
--- a/drivers/clk/rockchip/clk-rk3399.c
+++ b/drivers/clk/rockchip/clk-rk3399.c
@@ -622,7 +622,7 @@ static struct rockchip_clk_branch rk3399_clk_branches[] __initdata = {
 	GATE(SCLK_I2S2_8CH, "clk_i2s2", "clk_i2s2_mux", CLK_SET_RATE_PARENT,
 			RK3399_CLKGATE_CON(8), 11, GFLAGS),
 
-	MUX(0, "clk_i2sout_src", mux_i2sch_p, CLK_SET_RATE_PARENT,
+	MUX(SCLK_I2SOUT_SRC, "clk_i2sout_src", mux_i2sch_p, CLK_SET_RATE_PARENT,
 			RK3399_CLKSEL_CON(31), 0, 2, MFLAGS),
 	COMPOSITE_NODIV(SCLK_I2S_8CH_OUT, "clk_i2sout", mux_i2sout_p, CLK_SET_RATE_PARENT,
 			RK3399_CLKSEL_CON(31), 2, 1, MFLAGS,
diff --git a/include/dt-bindings/clock/rk3399-cru.h b/include/dt-bindings/clock/rk3399-cru.h
index 44e0a319f0770..b7b07dfda0fc6 100644
--- a/include/dt-bindings/clock/rk3399-cru.h
+++ b/include/dt-bindings/clock/rk3399-cru.h
@@ -19,6 +19,7 @@
 #define ARMCLKB				9
 
 /* sclk gates (special clocks) */
+#define SCLK_I2SOUT_SRC			64
 #define SCLK_I2C1			65
 #define SCLK_I2C2			66
 #define SCLK_I2C3			67
-- 
2.32.0


From f22253bea38b368fe9ceca5b8ec997a5d143da4e Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:27 -0400
Subject: [PATCH 22/26] [armbian] rk3399-bump-voltages-for-low-opps.patch

---
 arch/arm64/boot/dts/rockchip/rk3399-opp.dtsi | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-opp.dtsi b/arch/arm64/boot/dts/rockchip/rk3399-opp.dtsi
index d6f1095abb040..b6d86f681cf4a 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-opp.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3399-opp.dtsi
@@ -10,12 +10,12 @@ cluster0_opp: opp-table0 {
 
 		opp00 {
 			opp-hz = /bits/ 64 <408000000>;
-			opp-microvolt = <800000>;
+			opp-microvolt = <825000>;
 			clock-latency-ns = <40000>;
 		};
 		opp01 {
 			opp-hz = /bits/ 64 <600000000>;
-			opp-microvolt = <800000>;
+			opp-microvolt = <825000>;
 		};
 		opp02 {
 			opp-hz = /bits/ 64 <816000000>;
@@ -41,12 +41,12 @@ cluster1_opp: opp-table1 {
 
 		opp00 {
 			opp-hz = /bits/ 64 <408000000>;
-			opp-microvolt = <800000>;
+			opp-microvolt = <825000>;
 			clock-latency-ns = <40000>;
 		};
 		opp01 {
 			opp-hz = /bits/ 64 <600000000>;
-			opp-microvolt = <800000>;
+			opp-microvolt = <825000>;
 		};
 		opp02 {
 			opp-hz = /bits/ 64 <816000000>;
-- 
2.32.0


From de10c41377bec91dfeb06c5c2341c339f2c0f4b6 Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:27 -0400
Subject: [PATCH 23/26] [armbian] rk3399-enable-dwc3-xhci-usb-trb-quirk.patch

---
 arch/arm64/boot/dts/rockchip/rk3399.dtsi | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399.dtsi b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
index 4b6065dbba55e..711e654b12ee1 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
@@ -424,6 +424,7 @@ usbdrd_dwc3_0: usb@fe800000 {
 			snps,dis_u2_susphy_quirk;
 			snps,dis-del-phy-power-chg-quirk;
 			snps,dis-tx-ipgap-linecheck-quirk;
+			snps,xhci-trb-ent-quirk;
 			power-domains = <&power RK3399_PD_USB3>;
 			status = "disabled";
 		};
@@ -460,6 +461,7 @@ usbdrd_dwc3_1: usb@fe900000 {
 			snps,dis_u2_susphy_quirk;
 			snps,dis-del-phy-power-chg-quirk;
 			snps,dis-tx-ipgap-linecheck-quirk;
+			snps,xhci-trb-ent-quirk;
 			power-domains = <&power RK3399_PD_USB3>;
 			status = "disabled";
 		};
-- 
2.32.0


From 91e49c161773d6bf2407e2aa709cf0c4c3b4dda2 Mon Sep 17 00:00:00 2001
From: Igor Pecovnik <igor.pecovnik@gmail.com>
Date: Sun, 7 Mar 2021 15:24:02 +0100
Subject: [PATCH 24/26] PCI: rockchip: support ep-gpio undefined case

Signed-off-by: Aditya Prayoga <aditya@kobol.io>
Changed by: Igor Pecovnik <igor.pecovnik@gmail.com>
---
 drivers/pci/controller/pcie-rockchip.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/drivers/pci/controller/pcie-rockchip.c b/drivers/pci/controller/pcie-rockchip.c
index 990a00e08bc5b..193d26562aa6d 100644
--- a/drivers/pci/controller/pcie-rockchip.c
+++ b/drivers/pci/controller/pcie-rockchip.c
@@ -118,8 +118,7 @@ int rockchip_pcie_parse_dt(struct rockchip_pcie *rockchip)
 	}
 
 	if (rockchip->is_rc) {
-		rockchip->ep_gpio = devm_gpiod_get_optional(dev, "ep",
-							    GPIOD_OUT_HIGH);
+		rockchip->ep_gpio = devm_gpiod_get_optional(dev, "ep", GPIOD_OUT_HIGH);
 		if (IS_ERR(rockchip->ep_gpio))
 			return dev_err_probe(dev, PTR_ERR(rockchip->ep_gpio),
 					     "failed to get ep GPIO\n");
-- 
2.32.0


From 8991f4191b1b2e1c5a0f291db80b397006c47491 Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:27 -0400
Subject: [PATCH 25/26] [armbian] rk3399-sd-drive-level-8ma.patch

---
 arch/arm64/boot/dts/rockchip/rk3399.dtsi | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399.dtsi b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
index 711e654b12ee1..40b56bd947480 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
@@ -2312,25 +2312,25 @@ sdio0_int: sdio0-int {
 		sdmmc {
 			sdmmc_bus1: sdmmc-bus1 {
 				rockchip,pins =
-					<4 RK_PB0 1 &pcfg_pull_up>;
+					<4 RK_PB0 1 &pcfg_pull_up_8ma>;
 			};
 
 			sdmmc_bus4: sdmmc-bus4 {
 				rockchip,pins =
-					<4 RK_PB0 1 &pcfg_pull_up>,
-					<4 RK_PB1 1 &pcfg_pull_up>,
-					<4 RK_PB2 1 &pcfg_pull_up>,
-					<4 RK_PB3 1 &pcfg_pull_up>;
+					<4 RK_PB0 1 &pcfg_pull_up_8ma>,
+					<4 RK_PB1 1 &pcfg_pull_up_8ma>,
+					<4 RK_PB2 1 &pcfg_pull_up_8ma>,
+					<4 RK_PB3 1 &pcfg_pull_up_8ma>;
 			};
 
 			sdmmc_clk: sdmmc-clk {
 				rockchip,pins =
-					<4 RK_PB4 1 &pcfg_pull_none>;
+					<4 RK_PB4 1 &pcfg_pull_none_12ma>;
 			};
 
 			sdmmc_cmd: sdmmc-cmd {
 				rockchip,pins =
-					<4 RK_PB5 1 &pcfg_pull_up>;
+					<4 RK_PB5 1 &pcfg_pull_up_8ma>;
 			};
 
 			sdmmc_cd: sdmmc-cd {
@@ -2340,7 +2340,7 @@ sdmmc_cd: sdmmc-cd {
 
 			sdmmc_wp: sdmmc-wp {
 				rockchip,pins =
-					<0 RK_PB0 1 &pcfg_pull_up>;
+					<0 RK_PB0 1 &pcfg_pull_up_8ma>;
 			};
 		};
 
-- 
2.32.0


From aee8e09651edb6fa65425e845c5bfd0a4a7716ae Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Sat, 25 Sep 2021 20:59:28 -0400
Subject: [PATCH 26/26] [armbian] rk3399-unlock-temperature.patch

---
 arch/arm64/boot/dts/rockchip/rk3399.dtsi | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399.dtsi b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
index 40b56bd947480..5e21370fcb489 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
@@ -774,17 +774,17 @@ cpu_thermal: cpu {
 
 			trips {
 				cpu_alert0: cpu_alert0 {
-					temperature = <70000>;
+					temperature = <85000>;
 					hysteresis = <2000>;
 					type = "passive";
 				};
 				cpu_alert1: cpu_alert1 {
-					temperature = <75000>;
+					temperature = <95000>;
 					hysteresis = <2000>;
 					type = "passive";
 				};
 				cpu_crit: cpu_crit {
-					temperature = <95000>;
+					temperature = <100000>;
 					hysteresis = <2000>;
 					type = "critical";
 				};
-- 
2.32.0

